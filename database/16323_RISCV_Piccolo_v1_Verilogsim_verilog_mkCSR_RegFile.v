// This program was cloned from: https://github.com/rsnikhil/RISCV_Piccolo_v1
// License: MIT License

//
// Generated by Bluespec Compiler, version 2016.03.beta1 (build 34761, 2016-03-16)
//
// On Sat Jul  9 18:53:24 EDT 2016
//
//
// Ports:
// Name                         I/O  size props
// RDY_reset_start                O     1 const
// RDY_reset_complete             O     1 const
// mav_read                       O    33
// read_mstatus                   O    32
// read_mtvec                     O    32 const
// read_mepc                      O    32 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// mav_read_csr_addr              I    12
// ma_write_csr_addr              I    12
// ma_write_word                  I    32
// write_mepc_epc                 I    32
// write_mcause_cause             I    32
// write_mbadaddr_badaddr         I    32
// EN_reset_start                 I     1
// EN_reset_complete              I     1 unused
// EN_ma_write                    I     1
// EN_push_mstatus                I     1
// EN_pop_mstatus                 I     1
// EN_write_mepc                  I     1
// EN_write_mcause                I     1
// EN_write_mbadaddr              I     1
// EN_incr_instret                I     1
// EN_mav_read                    I     1 unused
//
// Combinational paths from inputs to outputs:
//   mav_read_csr_addr -> mav_read
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkCSR_RegFile(CLK,
		     RST_N,

		     EN_reset_start,
		     RDY_reset_start,

		     EN_reset_complete,
		     RDY_reset_complete,

		     mav_read_csr_addr,
		     EN_mav_read,
		     mav_read,

		     ma_write_csr_addr,
		     ma_write_word,
		     EN_ma_write,

		     read_mstatus,

		     EN_push_mstatus,

		     EN_pop_mstatus,

		     read_mtvec,

		     read_mepc,

		     write_mepc_epc,
		     EN_write_mepc,

		     write_mcause_cause,
		     EN_write_mcause,

		     write_mbadaddr_badaddr,
		     EN_write_mbadaddr,

		     EN_incr_instret);
  input  CLK;
  input  RST_N;

  // action method reset_start
  input  EN_reset_start;
  output RDY_reset_start;

  // action method reset_complete
  input  EN_reset_complete;
  output RDY_reset_complete;

  // actionvalue method mav_read
  input  [11 : 0] mav_read_csr_addr;
  input  EN_mav_read;
  output [32 : 0] mav_read;

  // action method ma_write
  input  [11 : 0] ma_write_csr_addr;
  input  [31 : 0] ma_write_word;
  input  EN_ma_write;

  // value method read_mstatus
  output [31 : 0] read_mstatus;

  // action method push_mstatus
  input  EN_push_mstatus;

  // action method pop_mstatus
  input  EN_pop_mstatus;

  // value method read_mtvec
  output [31 : 0] read_mtvec;

  // value method read_mepc
  output [31 : 0] read_mepc;

  // action method write_mepc
  input  [31 : 0] write_mepc_epc;
  input  EN_write_mepc;

  // action method write_mcause
  input  [31 : 0] write_mcause_cause;
  input  EN_write_mcause;

  // action method write_mbadaddr
  input  [31 : 0] write_mbadaddr_badaddr;
  input  EN_write_mbadaddr;

  // action method incr_instret
  input  EN_incr_instret;

  // signals for module outputs
  wire [32 : 0] mav_read;
  wire [31 : 0] read_mepc, read_mstatus, read_mtvec;
  wire RDY_reset_complete, RDY_reset_start;

  // inlined wires
  wire rw_mbadaddr0$whas, rw_mcause0$whas, rw_mepc0$whas, rw_mstatus0$whas;

  // register rg_cycle
  reg [63 : 0] rg_cycle;
  wire [63 : 0] rg_cycle$D_IN;
  wire rg_cycle$EN;

  // register rg_instret
  reg [63 : 0] rg_instret;
  wire [63 : 0] rg_instret$D_IN;
  wire rg_instret$EN;

  // register rg_mbadaddr
  reg [31 : 0] rg_mbadaddr;
  wire [31 : 0] rg_mbadaddr$D_IN;
  wire rg_mbadaddr$EN;

  // register rg_mcause_exc_code
  reg [3 : 0] rg_mcause_exc_code;
  wire [3 : 0] rg_mcause_exc_code$D_IN;
  wire rg_mcause_exc_code$EN;

  // register rg_mcause_interrupt
  reg rg_mcause_interrupt;
  wire rg_mcause_interrupt$D_IN, rg_mcause_interrupt$EN;

  // register rg_mepc
  reg [31 : 0] rg_mepc;
  wire [31 : 0] rg_mepc$D_IN;
  wire rg_mepc$EN;

  // register rg_mie_msie
  reg rg_mie_msie;
  wire rg_mie_msie$D_IN, rg_mie_msie$EN;

  // register rg_mie_mtie
  reg rg_mie_mtie;
  wire rg_mie_mtie$D_IN, rg_mie_mtie$EN;

  // register rg_mip_msip
  reg rg_mip_msip;
  wire rg_mip_msip$D_IN, rg_mip_msip$EN;

  // register rg_mip_mtip
  reg rg_mip_mtip;
  wire rg_mip_mtip$D_IN, rg_mip_mtip$EN;

  // register rg_mscratch
  reg [31 : 0] rg_mscratch;
  wire [31 : 0] rg_mscratch$D_IN;
  wire rg_mscratch$EN;

  // register rg_mstatus
  reg [5 : 0] rg_mstatus;
  wire [5 : 0] rg_mstatus$D_IN;
  wire rg_mstatus$EN;

  // register rg_mtime
  reg [63 : 0] rg_mtime;
  wire [63 : 0] rg_mtime$D_IN;
  wire rg_mtime$EN;

  // register rg_mtimecmp
  reg [31 : 0] rg_mtimecmp;
  wire [31 : 0] rg_mtimecmp$D_IN;
  wire rg_mtimecmp$EN;

  // rule scheduling signals
  wire CAN_FIRE_RL_rl_upd_cycle_csrrx,
       CAN_FIRE_RL_rl_upd_cycle_incr,
       CAN_FIRE_RL_rl_upd_instret_csrrx,
       CAN_FIRE_RL_rl_upd_instret_incr,
       CAN_FIRE_RL_rl_upd_mbadaddr,
       CAN_FIRE_RL_rl_upd_mcause,
       CAN_FIRE_RL_rl_upd_mepc,
       CAN_FIRE_RL_rl_upd_mstatus,
       CAN_FIRE_RL_rl_upd_mtime_csrrx,
       CAN_FIRE_RL_rl_upd_mtime_incr,
       CAN_FIRE_incr_instret,
       CAN_FIRE_ma_write,
       CAN_FIRE_mav_read,
       CAN_FIRE_pop_mstatus,
       CAN_FIRE_push_mstatus,
       CAN_FIRE_reset_complete,
       CAN_FIRE_reset_start,
       CAN_FIRE_write_mbadaddr,
       CAN_FIRE_write_mcause,
       CAN_FIRE_write_mepc,
       WILL_FIRE_RL_rl_upd_cycle_csrrx,
       WILL_FIRE_RL_rl_upd_cycle_incr,
       WILL_FIRE_RL_rl_upd_instret_csrrx,
       WILL_FIRE_RL_rl_upd_instret_incr,
       WILL_FIRE_RL_rl_upd_mbadaddr,
       WILL_FIRE_RL_rl_upd_mcause,
       WILL_FIRE_RL_rl_upd_mepc,
       WILL_FIRE_RL_rl_upd_mstatus,
       WILL_FIRE_RL_rl_upd_mtime_csrrx,
       WILL_FIRE_RL_rl_upd_mtime_incr,
       WILL_FIRE_incr_instret,
       WILL_FIRE_ma_write,
       WILL_FIRE_mav_read,
       WILL_FIRE_pop_mstatus,
       WILL_FIRE_push_mstatus,
       WILL_FIRE_reset_complete,
       WILL_FIRE_reset_start,
       WILL_FIRE_write_mbadaddr,
       WILL_FIRE_write_mcause,
       WILL_FIRE_write_mepc;

  // inputs to muxes for submodule ports
  reg [63 : 0] MUX_rw_mtime$wset_1__VAL_1;
  wire [63 : 0] MUX_rg_cycle$write_1__VAL_1,
		MUX_rg_cycle$write_1__VAL_2,
		MUX_rg_instret$write_1__VAL_1,
		MUX_rg_instret$write_1__VAL_2,
		MUX_rg_mtime$write_1__VAL_1,
		MUX_rg_mtime$write_1__VAL_2,
		MUX_rw_cycle$wset_1__VAL_1,
		MUX_rw_instret$wset_1__VAL_1;
  wire MUX_rg_mie_msie$write_1__SEL_1,
       MUX_rg_mip_msip$write_1__SEL_1,
       MUX_rg_mip_mtip$write_1__SEL_1,
       MUX_rg_mip_mtip$write_1__VAL_1,
       MUX_rg_mtimecmp$write_1__SEL_1,
       MUX_rw_cycle$wset_1__SEL_1,
       MUX_rw_instret$wset_1__SEL_1,
       MUX_rw_mstatus0$wset_1__SEL_1,
       MUX_rw_mtime$wset_1__SEL_1;

  // remaining internal signals
  reg [31 : 0] IF_mav_read_csr_addr_EQ_0xF00_1_THEN_1052928_E_ETC___d175,
	       v__h2478,
	       v__h2484;
  wire [63 : 0] new_cycle_value__h2282,
		new_cycle_value__h2288,
		new_instret_value__h2306,
		new_instret_value__h2312,
		new_mtime_value__h2294,
		new_mtime_value__h2300;
  wire [5 : 0] x__h1227, x__h1234, x__h1241;
  wire [4 : 0] ab__h1360, ab__h1384;

  // action method reset_start
  assign RDY_reset_start = 1'd1 ;
  assign CAN_FIRE_reset_start = 1'd1 ;
  assign WILL_FIRE_reset_start = EN_reset_start ;

  // action method reset_complete
  assign RDY_reset_complete = 1'd1 ;
  assign CAN_FIRE_reset_complete = 1'd1 ;
  assign WILL_FIRE_reset_complete = EN_reset_complete ;

  // actionvalue method mav_read
  assign mav_read =
	     { mav_read_csr_addr == 12'hF00 || mav_read_csr_addr == 12'hF01 ||
	       mav_read_csr_addr == 12'hF10 ||
	       mav_read_csr_addr == 12'h300 ||
	       mav_read_csr_addr == 12'h301 ||
	       mav_read_csr_addr == 12'h302 ||
	       mav_read_csr_addr == 12'h344 ||
	       mav_read_csr_addr == 12'h304 ||
	       mav_read_csr_addr == 12'h701 ||
	       mav_read_csr_addr == 12'h741 ||
	       mav_read_csr_addr == 12'h321 ||
	       mav_read_csr_addr == 12'h340 ||
	       mav_read_csr_addr == 12'h341 ||
	       mav_read_csr_addr == 12'h342 ||
	       mav_read_csr_addr == 12'h343 ||
	       mav_read_csr_addr == 12'hC00 ||
	       mav_read_csr_addr == 12'hC01 ||
	       mav_read_csr_addr == 12'hC02 ||
	       mav_read_csr_addr == 12'hC80 ||
	       mav_read_csr_addr == 12'hC81 ||
	       mav_read_csr_addr == 12'hC82,
	       IF_mav_read_csr_addr_EQ_0xF00_1_THEN_1052928_E_ETC___d175 } ;
  assign CAN_FIRE_mav_read = 1'd1 ;
  assign WILL_FIRE_mav_read = EN_mav_read ;

  // action method ma_write
  assign CAN_FIRE_ma_write = 1'd1 ;
  assign WILL_FIRE_ma_write = EN_ma_write ;

  // value method read_mstatus
  assign read_mstatus = { 26'd0, rg_mstatus } ;

  // action method push_mstatus
  assign CAN_FIRE_push_mstatus = 1'd1 ;
  assign WILL_FIRE_push_mstatus = EN_push_mstatus ;

  // action method pop_mstatus
  assign CAN_FIRE_pop_mstatus = 1'd1 ;
  assign WILL_FIRE_pop_mstatus = EN_pop_mstatus ;

  // value method read_mtvec
  assign read_mtvec = 32'h00000100 ;

  // value method read_mepc
  assign read_mepc = rg_mepc ;

  // action method write_mepc
  assign CAN_FIRE_write_mepc = 1'd1 ;
  assign WILL_FIRE_write_mepc = EN_write_mepc ;

  // action method write_mcause
  assign CAN_FIRE_write_mcause = 1'd1 ;
  assign WILL_FIRE_write_mcause = EN_write_mcause ;

  // action method write_mbadaddr
  assign CAN_FIRE_write_mbadaddr = 1'd1 ;
  assign WILL_FIRE_write_mbadaddr = EN_write_mbadaddr ;

  // action method incr_instret
  assign CAN_FIRE_incr_instret = 1'd1 ;
  assign WILL_FIRE_incr_instret = EN_incr_instret ;

  // rule RL_rl_upd_mstatus
  assign CAN_FIRE_RL_rl_upd_mstatus = 1'd1 ;
  assign WILL_FIRE_RL_rl_upd_mstatus = 1'd1 ;

  // rule RL_rl_upd_mepc
  assign CAN_FIRE_RL_rl_upd_mepc = 1'd1 ;
  assign WILL_FIRE_RL_rl_upd_mepc = 1'd1 ;

  // rule RL_rl_upd_mcause
  assign CAN_FIRE_RL_rl_upd_mcause = 1'd1 ;
  assign WILL_FIRE_RL_rl_upd_mcause = 1'd1 ;

  // rule RL_rl_upd_mbadaddr
  assign CAN_FIRE_RL_rl_upd_mbadaddr = 1'd1 ;
  assign WILL_FIRE_RL_rl_upd_mbadaddr = 1'd1 ;

  // rule RL_rl_upd_cycle_csrrx
  assign CAN_FIRE_RL_rl_upd_cycle_csrrx =
	     MUX_rw_cycle$wset_1__SEL_1 || EN_reset_start ;
  assign WILL_FIRE_RL_rl_upd_cycle_csrrx = CAN_FIRE_RL_rl_upd_cycle_csrrx ;

  // rule RL_rl_upd_cycle_incr
  assign CAN_FIRE_RL_rl_upd_cycle_incr = !CAN_FIRE_RL_rl_upd_cycle_csrrx ;
  assign WILL_FIRE_RL_rl_upd_cycle_incr = CAN_FIRE_RL_rl_upd_cycle_incr ;

  // rule RL_rl_upd_mtime_csrrx
  assign CAN_FIRE_RL_rl_upd_mtime_csrrx =
	     MUX_rw_mtime$wset_1__SEL_1 || EN_reset_start ;
  assign WILL_FIRE_RL_rl_upd_mtime_csrrx = CAN_FIRE_RL_rl_upd_mtime_csrrx ;

  // rule RL_rl_upd_mtime_incr
  assign CAN_FIRE_RL_rl_upd_mtime_incr = !CAN_FIRE_RL_rl_upd_mtime_csrrx ;
  assign WILL_FIRE_RL_rl_upd_mtime_incr = CAN_FIRE_RL_rl_upd_mtime_incr ;

  // rule RL_rl_upd_instret_csrrx
  assign CAN_FIRE_RL_rl_upd_instret_csrrx =
	     MUX_rw_instret$wset_1__SEL_1 || EN_reset_start ;
  assign WILL_FIRE_RL_rl_upd_instret_csrrx =
	     CAN_FIRE_RL_rl_upd_instret_csrrx ;

  // rule RL_rl_upd_instret_incr
  assign CAN_FIRE_RL_rl_upd_instret_incr =
	     !CAN_FIRE_RL_rl_upd_instret_csrrx && EN_incr_instret ;
  assign WILL_FIRE_RL_rl_upd_instret_incr = CAN_FIRE_RL_rl_upd_instret_incr ;

  // inputs to muxes for submodule ports
  assign MUX_rg_mie_msie$write_1__SEL_1 =
	     EN_ma_write && ma_write_csr_addr == 12'h304 ;
  assign MUX_rg_mip_msip$write_1__SEL_1 =
	     EN_ma_write && ma_write_csr_addr == 12'h344 ;
  assign MUX_rg_mip_mtip$write_1__SEL_1 =
	     EN_ma_write &&
	     (ma_write_csr_addr == 12'h344 || ma_write_csr_addr == 12'h321) ;
  assign MUX_rg_mtimecmp$write_1__SEL_1 =
	     EN_ma_write && ma_write_csr_addr == 12'h321 ;
  assign MUX_rw_cycle$wset_1__SEL_1 =
	     EN_ma_write &&
	     (ma_write_csr_addr == 12'hC00 || ma_write_csr_addr == 12'hC80) ;
  assign MUX_rw_instret$wset_1__SEL_1 =
	     EN_ma_write &&
	     (ma_write_csr_addr == 12'hC02 || ma_write_csr_addr == 12'hC82) ;
  assign MUX_rw_mstatus0$wset_1__SEL_1 =
	     EN_ma_write && ma_write_csr_addr == 12'h300 ;
  assign MUX_rw_mtime$wset_1__SEL_1 =
	     EN_ma_write &&
	     (ma_write_csr_addr == 12'h701 || ma_write_csr_addr == 12'h741 ||
	      ma_write_csr_addr == 12'hC01 ||
	      ma_write_csr_addr == 12'hC81) ;
  assign MUX_rg_cycle$write_1__VAL_1 =
	     MUX_rw_cycle$wset_1__SEL_1 ? MUX_rw_cycle$wset_1__VAL_1 : 64'd0 ;
  assign MUX_rg_cycle$write_1__VAL_2 = rg_cycle + 64'd1 ;
  assign MUX_rg_instret$write_1__VAL_1 =
	     MUX_rw_instret$wset_1__SEL_1 ?
	       MUX_rw_instret$wset_1__VAL_1 :
	       64'd0 ;
  assign MUX_rg_instret$write_1__VAL_2 = rg_instret + 64'd1 ;
  assign MUX_rg_mip_mtip$write_1__VAL_1 =
	     ma_write_csr_addr == 12'h344 && ma_write_word[7] ;
  assign MUX_rg_mtime$write_1__VAL_1 =
	     MUX_rw_mtime$wset_1__SEL_1 ? MUX_rw_mtime$wset_1__VAL_1 : 64'd0 ;
  assign MUX_rg_mtime$write_1__VAL_2 = rg_mtime + 64'd1 ;
  assign MUX_rw_cycle$wset_1__VAL_1 =
	     (ma_write_csr_addr == 12'hC00) ?
	       new_cycle_value__h2282 :
	       new_cycle_value__h2288 ;
  assign MUX_rw_instret$wset_1__VAL_1 =
	     (ma_write_csr_addr == 12'hC02) ?
	       new_instret_value__h2306 :
	       new_instret_value__h2312 ;
  always@(ma_write_csr_addr or
	  new_mtime_value__h2300 or new_mtime_value__h2294)
  begin
    case (ma_write_csr_addr)
      12'h701, 12'hC01: MUX_rw_mtime$wset_1__VAL_1 = new_mtime_value__h2294;
      12'h741: MUX_rw_mtime$wset_1__VAL_1 = new_mtime_value__h2300;
      default: MUX_rw_mtime$wset_1__VAL_1 = new_mtime_value__h2300;
    endcase
  end

  // inlined wires
  assign rw_mstatus0$whas =
	     EN_ma_write && ma_write_csr_addr == 12'h300 || EN_reset_start ;
  assign rw_mepc0$whas = EN_ma_write && ma_write_csr_addr == 12'h341 ;
  assign rw_mcause0$whas = EN_ma_write && ma_write_csr_addr == 12'h342 ;
  assign rw_mbadaddr0$whas = EN_ma_write && ma_write_csr_addr == 12'h343 ;

  // register rg_cycle
  assign rg_cycle$D_IN =
	     WILL_FIRE_RL_rl_upd_cycle_csrrx ?
	       MUX_rg_cycle$write_1__VAL_1 :
	       MUX_rg_cycle$write_1__VAL_2 ;
  assign rg_cycle$EN =
	     WILL_FIRE_RL_rl_upd_cycle_csrrx ||
	     WILL_FIRE_RL_rl_upd_cycle_incr ;

  // register rg_instret
  assign rg_instret$D_IN =
	     WILL_FIRE_RL_rl_upd_instret_csrrx ?
	       MUX_rg_instret$write_1__VAL_1 :
	       MUX_rg_instret$write_1__VAL_2 ;
  assign rg_instret$EN =
	     WILL_FIRE_RL_rl_upd_instret_csrrx ||
	     WILL_FIRE_RL_rl_upd_instret_incr ;

  // register rg_mbadaddr
  assign rg_mbadaddr$D_IN =
	     EN_write_mbadaddr ? write_mbadaddr_badaddr : ma_write_word ;
  assign rg_mbadaddr$EN = EN_write_mbadaddr || rw_mbadaddr0$whas ;

  // register rg_mcause_exc_code
  assign rg_mcause_exc_code$D_IN =
	     EN_write_mcause ? ab__h1360[3:0] : ab__h1384[3:0] ;
  assign rg_mcause_exc_code$EN = EN_write_mcause || rw_mcause0$whas ;

  // register rg_mcause_interrupt
  assign rg_mcause_interrupt$D_IN =
	     EN_write_mcause ? ab__h1360[4] : ab__h1384[4] ;
  assign rg_mcause_interrupt$EN = EN_write_mcause || rw_mcause0$whas ;

  // register rg_mepc
  assign rg_mepc$D_IN = EN_write_mepc ? write_mepc_epc : ma_write_word ;
  assign rg_mepc$EN = EN_write_mepc || rw_mepc0$whas ;

  // register rg_mie_msie
  assign rg_mie_msie$D_IN =
	     MUX_rg_mie_msie$write_1__SEL_1 && ma_write_word[3] ;
  assign rg_mie_msie$EN =
	     EN_ma_write && ma_write_csr_addr == 12'h304 || EN_reset_start ;

  // register rg_mie_mtie
  assign rg_mie_mtie$D_IN =
	     MUX_rg_mie_msie$write_1__SEL_1 && ma_write_word[7] ;
  assign rg_mie_mtie$EN =
	     EN_ma_write && ma_write_csr_addr == 12'h304 || EN_reset_start ;

  // register rg_mip_msip
  assign rg_mip_msip$D_IN =
	     MUX_rg_mip_msip$write_1__SEL_1 && ma_write_word[3] ;
  assign rg_mip_msip$EN =
	     EN_ma_write && ma_write_csr_addr == 12'h344 || EN_reset_start ;

  // register rg_mip_mtip
  assign rg_mip_mtip$D_IN =
	     MUX_rg_mip_mtip$write_1__SEL_1 &&
	     MUX_rg_mip_mtip$write_1__VAL_1 ;
  assign rg_mip_mtip$EN =
	     EN_ma_write &&
	     (ma_write_csr_addr == 12'h344 || ma_write_csr_addr == 12'h321) ||
	     EN_reset_start ;

  // register rg_mscratch
  assign rg_mscratch$D_IN = ma_write_word ;
  assign rg_mscratch$EN = EN_ma_write && ma_write_csr_addr == 12'h340 ;

  // register rg_mstatus
  assign rg_mstatus$D_IN =
	     EN_pop_mstatus ?
	       x__h1227 :
	       (EN_push_mstatus ? x__h1234 : x__h1241) ;
  assign rg_mstatus$EN =
	     EN_pop_mstatus || EN_push_mstatus || rw_mstatus0$whas ;

  // register rg_mtime
  assign rg_mtime$D_IN =
	     WILL_FIRE_RL_rl_upd_mtime_csrrx ?
	       MUX_rg_mtime$write_1__VAL_1 :
	       MUX_rg_mtime$write_1__VAL_2 ;
  assign rg_mtime$EN =
	     WILL_FIRE_RL_rl_upd_mtime_csrrx ||
	     WILL_FIRE_RL_rl_upd_mtime_incr ;

  // register rg_mtimecmp
  assign rg_mtimecmp$D_IN =
	     MUX_rg_mtimecmp$write_1__SEL_1 ? ma_write_word : 32'd0 ;
  assign rg_mtimecmp$EN =
	     EN_ma_write && ma_write_csr_addr == 12'h321 || EN_reset_start ;

  // remaining internal signals
  assign ab__h1360 = { write_mcause_cause[31], write_mcause_cause[3:0] } ;
  assign ab__h1384 = { ma_write_word[31], ma_write_word[3:0] } ;
  assign new_cycle_value__h2282 = { rg_cycle[63:32], ma_write_word } ;
  assign new_cycle_value__h2288 = { ma_write_word, rg_cycle[31:0] } ;
  assign new_instret_value__h2306 = { rg_instret[63:32], ma_write_word } ;
  assign new_instret_value__h2312 = { ma_write_word, rg_instret[31:0] } ;
  assign new_mtime_value__h2294 = { rg_mtime[63:32], ma_write_word } ;
  assign new_mtime_value__h2300 = { ma_write_word, rg_mtime[31:0] } ;
  assign x__h1227 = { 3'd1, rg_mstatus[5:3] } ;
  assign x__h1234 = { rg_mstatus[2:0], 3'd6 } ;
  assign x__h1241 =
	     MUX_rw_mstatus0$wset_1__SEL_1 ? ma_write_word[5:0] : 6'd62 ;
  always@(mav_read_csr_addr or
	  rg_instret or
	  rg_mstatus or
	  rg_mie_mtie or
	  rg_mie_msie or
	  rg_mtimecmp or
	  rg_mscratch or
	  rg_mepc or
	  rg_mcause_interrupt or
	  rg_mcause_exc_code or
	  rg_mbadaddr or rg_mip_mtip or rg_mip_msip or rg_mtime or rg_cycle)
  begin
    case (mav_read_csr_addr)
      12'h300:
	  IF_mav_read_csr_addr_EQ_0xF00_1_THEN_1052928_E_ETC___d175 =
	      { 26'd0, rg_mstatus };
      12'h301:
	  IF_mav_read_csr_addr_EQ_0xF00_1_THEN_1052928_E_ETC___d175 =
	      32'h00000100;
      12'h302, 12'hF10:
	  IF_mav_read_csr_addr_EQ_0xF00_1_THEN_1052928_E_ETC___d175 = 32'd0;
      12'h304:
	  IF_mav_read_csr_addr_EQ_0xF00_1_THEN_1052928_E_ETC___d175 =
	      { 24'd0, rg_mie_mtie, 3'b0, rg_mie_msie, 3'b0 };
      12'h321:
	  IF_mav_read_csr_addr_EQ_0xF00_1_THEN_1052928_E_ETC___d175 =
	      rg_mtimecmp;
      12'h340:
	  IF_mav_read_csr_addr_EQ_0xF00_1_THEN_1052928_E_ETC___d175 =
	      rg_mscratch;
      12'h341:
	  IF_mav_read_csr_addr_EQ_0xF00_1_THEN_1052928_E_ETC___d175 = rg_mepc;
      12'h342:
	  IF_mav_read_csr_addr_EQ_0xF00_1_THEN_1052928_E_ETC___d175 =
	      { rg_mcause_interrupt, 27'd0, rg_mcause_exc_code };
      12'h343:
	  IF_mav_read_csr_addr_EQ_0xF00_1_THEN_1052928_E_ETC___d175 =
	      rg_mbadaddr;
      12'h344:
	  IF_mav_read_csr_addr_EQ_0xF00_1_THEN_1052928_E_ETC___d175 =
	      { 24'd0, rg_mip_mtip, 3'b0, rg_mip_msip, 3'b0 };
      12'h701, 12'hC01:
	  IF_mav_read_csr_addr_EQ_0xF00_1_THEN_1052928_E_ETC___d175 =
	      rg_mtime[31:0];
      12'h741, 12'hC81:
	  IF_mav_read_csr_addr_EQ_0xF00_1_THEN_1052928_E_ETC___d175 =
	      rg_mtime[63:32];
      12'hC00:
	  IF_mav_read_csr_addr_EQ_0xF00_1_THEN_1052928_E_ETC___d175 =
	      rg_cycle[31:0];
      12'hC02:
	  IF_mav_read_csr_addr_EQ_0xF00_1_THEN_1052928_E_ETC___d175 =
	      rg_instret[31:0];
      12'hC80:
	  IF_mav_read_csr_addr_EQ_0xF00_1_THEN_1052928_E_ETC___d175 =
	      rg_cycle[63:32];
      12'hF00:
	  IF_mav_read_csr_addr_EQ_0xF00_1_THEN_1052928_E_ETC___d175 =
	      32'd1052928;
      12'hF01:
	  IF_mav_read_csr_addr_EQ_0xF00_1_THEN_1052928_E_ETC___d175 =
	      32'h00008000;
      default: IF_mav_read_csr_addr_EQ_0xF00_1_THEN_1052928_E_ETC___d175 =
		   rg_instret[63:32];
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        rg_cycle <= `BSV_ASSIGNMENT_DELAY 64'd0;
	rg_instret <= `BSV_ASSIGNMENT_DELAY 64'd0;
	rg_mstatus <= `BSV_ASSIGNMENT_DELAY 6'd62;
      end
    else
      begin
        if (rg_cycle$EN) rg_cycle <= `BSV_ASSIGNMENT_DELAY rg_cycle$D_IN;
	if (rg_instret$EN)
	  rg_instret <= `BSV_ASSIGNMENT_DELAY rg_instret$D_IN;
	if (rg_mstatus$EN)
	  rg_mstatus <= `BSV_ASSIGNMENT_DELAY rg_mstatus$D_IN;
      end
    if (rg_mbadaddr$EN) rg_mbadaddr <= `BSV_ASSIGNMENT_DELAY rg_mbadaddr$D_IN;
    if (rg_mcause_exc_code$EN)
      rg_mcause_exc_code <= `BSV_ASSIGNMENT_DELAY rg_mcause_exc_code$D_IN;
    if (rg_mcause_interrupt$EN)
      rg_mcause_interrupt <= `BSV_ASSIGNMENT_DELAY rg_mcause_interrupt$D_IN;
    if (rg_mepc$EN) rg_mepc <= `BSV_ASSIGNMENT_DELAY rg_mepc$D_IN;
    if (rg_mie_msie$EN) rg_mie_msie <= `BSV_ASSIGNMENT_DELAY rg_mie_msie$D_IN;
    if (rg_mie_mtie$EN) rg_mie_mtie <= `BSV_ASSIGNMENT_DELAY rg_mie_mtie$D_IN;
    if (rg_mip_msip$EN) rg_mip_msip <= `BSV_ASSIGNMENT_DELAY rg_mip_msip$D_IN;
    if (rg_mip_mtip$EN) rg_mip_mtip <= `BSV_ASSIGNMENT_DELAY rg_mip_mtip$D_IN;
    if (rg_mscratch$EN) rg_mscratch <= `BSV_ASSIGNMENT_DELAY rg_mscratch$D_IN;
    if (rg_mtime$EN) rg_mtime <= `BSV_ASSIGNMENT_DELAY rg_mtime$D_IN;
    if (rg_mtimecmp$EN) rg_mtimecmp <= `BSV_ASSIGNMENT_DELAY rg_mtimecmp$D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    rg_cycle = 64'hAAAAAAAAAAAAAAAA;
    rg_instret = 64'hAAAAAAAAAAAAAAAA;
    rg_mbadaddr = 32'hAAAAAAAA;
    rg_mcause_exc_code = 4'hA;
    rg_mcause_interrupt = 1'h0;
    rg_mepc = 32'hAAAAAAAA;
    rg_mie_msie = 1'h0;
    rg_mie_mtie = 1'h0;
    rg_mip_msip = 1'h0;
    rg_mip_mtip = 1'h0;
    rg_mscratch = 32'hAAAAAAAA;
    rg_mstatus = 6'h2A;
    rg_mtime = 64'hAAAAAAAAAAAAAAAA;
    rg_mtimecmp = 32'hAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_ma_write && ma_write_csr_addr != 12'hF00 &&
	  ma_write_csr_addr != 12'hF01 &&
	  ma_write_csr_addr != 12'hF10 &&
	  ma_write_csr_addr != 12'h300 &&
	  ma_write_csr_addr != 12'h301 &&
	  ma_write_csr_addr != 12'h302 &&
	  ma_write_csr_addr != 12'h344 &&
	  ma_write_csr_addr != 12'h304 &&
	  ma_write_csr_addr != 12'h701 &&
	  ma_write_csr_addr != 12'h741 &&
	  ma_write_csr_addr != 12'h321 &&
	  ma_write_csr_addr != 12'h340 &&
	  ma_write_csr_addr != 12'h341 &&
	  ma_write_csr_addr != 12'h342 &&
	  ma_write_csr_addr != 12'h343 &&
	  ma_write_csr_addr != 12'hC00 &&
	  ma_write_csr_addr != 12'hC80 &&
	  ma_write_csr_addr != 12'hC01 &&
	  ma_write_csr_addr != 12'hC81 &&
	  ma_write_csr_addr != 12'hC02 &&
	  ma_write_csr_addr != 12'hC82)
	begin
	  v__h2484 = $stime;
	  #0;
	end
    v__h2478 = v__h2484 / 32'd10;
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_ma_write && ma_write_csr_addr != 12'hF00 &&
	  ma_write_csr_addr != 12'hF01 &&
	  ma_write_csr_addr != 12'hF10 &&
	  ma_write_csr_addr != 12'h300 &&
	  ma_write_csr_addr != 12'h301 &&
	  ma_write_csr_addr != 12'h302 &&
	  ma_write_csr_addr != 12'h344 &&
	  ma_write_csr_addr != 12'h304 &&
	  ma_write_csr_addr != 12'h701 &&
	  ma_write_csr_addr != 12'h741 &&
	  ma_write_csr_addr != 12'h321 &&
	  ma_write_csr_addr != 12'h340 &&
	  ma_write_csr_addr != 12'h341 &&
	  ma_write_csr_addr != 12'h342 &&
	  ma_write_csr_addr != 12'h343 &&
	  ma_write_csr_addr != 12'hC00 &&
	  ma_write_csr_addr != 12'hC80 &&
	  ma_write_csr_addr != 12'hC01 &&
	  ma_write_csr_addr != 12'hC81 &&
	  ma_write_csr_addr != 12'hC02 &&
	  ma_write_csr_addr != 12'hC82)
	$display("%0d: ERROR: CSR 0x%0h not implemented; ignoring",
		 v__h2478,
		 ma_write_csr_addr);
  end
  // synopsys translate_on
endmodule  // mkCSR_RegFile

