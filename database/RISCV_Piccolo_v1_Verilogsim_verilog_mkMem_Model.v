// This program was cloned from: https://github.com/rsnikhil/RISCV_Piccolo_v1
// License: MIT License

//
// Generated by Bluespec Compiler, version 2016.03.beta1 (build 34761, 2016-03-16)
//
// On Sat Jul  9 18:53:09 EDT 2016
//
//
// Ports:
// Name                         I/O  size props
// RDY_request_put                O     1 reg
// response_get                   O   256 reg
// RDY_response_get               O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// request_put                    I   316 reg
// EN_request_put                 I     1
// EN_response_get                I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkMem_Model(CLK,
		   RST_N,

		   request_put,
		   EN_request_put,
		   RDY_request_put,

		   EN_response_get,
		   response_get,
		   RDY_response_get);
  input  CLK;
  input  RST_N;

  // action method request_put
  input  [315 : 0] request_put;
  input  EN_request_put;
  output RDY_request_put;

  // actionvalue method response_get
  input  EN_response_get;
  output [255 : 0] response_get;
  output RDY_response_get;

  // signals for module outputs
  wire [255 : 0] response_get;
  wire RDY_request_put, RDY_response_get;

  // ports of submodule f_raw_mem_reqs
  wire [315 : 0] f_raw_mem_reqs$D_IN, f_raw_mem_reqs$D_OUT;
  wire f_raw_mem_reqs$CLR,
       f_raw_mem_reqs$DEQ,
       f_raw_mem_reqs$EMPTY_N,
       f_raw_mem_reqs$ENQ,
       f_raw_mem_reqs$FULL_N;

  // ports of submodule f_raw_mem_rsps
  wire [255 : 0] f_raw_mem_rsps$D_IN, f_raw_mem_rsps$D_OUT;
  wire f_raw_mem_rsps$CLR,
       f_raw_mem_rsps$DEQ,
       f_raw_mem_rsps$EMPTY_N,
       f_raw_mem_rsps$ENQ,
       f_raw_mem_rsps$FULL_N;

  // ports of submodule rf
  wire [255 : 0] rf$D_IN, rf$D_OUT_1;
  wire [26 : 0] rf$ADDR_1,
		rf$ADDR_2,
		rf$ADDR_3,
		rf$ADDR_4,
		rf$ADDR_5,
		rf$ADDR_IN;
  wire rf$WE;

  // rule scheduling signals
  wire CAN_FIRE_RL_rl_process_reqs,
       CAN_FIRE_request_put,
       CAN_FIRE_response_get,
       WILL_FIRE_RL_rl_process_reqs,
       WILL_FIRE_request_put,
       WILL_FIRE_response_get;

  // action method request_put
  assign RDY_request_put = f_raw_mem_reqs$FULL_N ;
  assign CAN_FIRE_request_put = f_raw_mem_reqs$FULL_N ;
  assign WILL_FIRE_request_put = EN_request_put ;

  // actionvalue method response_get
  assign response_get = f_raw_mem_rsps$D_OUT ;
  assign RDY_response_get = f_raw_mem_rsps$EMPTY_N ;
  assign CAN_FIRE_response_get = f_raw_mem_rsps$EMPTY_N ;
  assign WILL_FIRE_response_get = EN_response_get ;

  // submodule f_raw_mem_reqs
  FIFO2 #(.width(32'd316), .guarded(32'd1)) f_raw_mem_reqs(.RST(RST_N),
							   .CLK(CLK),
							   .D_IN(f_raw_mem_reqs$D_IN),
							   .ENQ(f_raw_mem_reqs$ENQ),
							   .DEQ(f_raw_mem_reqs$DEQ),
							   .CLR(f_raw_mem_reqs$CLR),
							   .D_OUT(f_raw_mem_reqs$D_OUT),
							   .FULL_N(f_raw_mem_reqs$FULL_N),
							   .EMPTY_N(f_raw_mem_reqs$EMPTY_N));

  // submodule f_raw_mem_rsps
  FIFO2 #(.width(32'd256), .guarded(32'd1)) f_raw_mem_rsps(.RST(RST_N),
							   .CLK(CLK),
							   .D_IN(f_raw_mem_rsps$D_IN),
							   .ENQ(f_raw_mem_rsps$ENQ),
							   .DEQ(f_raw_mem_rsps$DEQ),
							   .CLR(f_raw_mem_rsps$CLR),
							   .D_OUT(f_raw_mem_rsps$D_OUT),
							   .FULL_N(f_raw_mem_rsps$FULL_N),
							   .EMPTY_N(f_raw_mem_rsps$EMPTY_N));

  // submodule rf
  RegFile #(.addr_width(32'd27),
	    .data_width(32'd256),
	    .lo(27'd0),
	    .hi(27'd65535)) rf(.CLK(CLK),
			       .ADDR_1(rf$ADDR_1),
			       .ADDR_2(rf$ADDR_2),
			       .ADDR_3(rf$ADDR_3),
			       .ADDR_4(rf$ADDR_4),
			       .ADDR_5(rf$ADDR_5),
			       .ADDR_IN(rf$ADDR_IN),
			       .D_IN(rf$D_IN),
			       .WE(rf$WE),
			       .D_OUT_1(rf$D_OUT_1),
			       .D_OUT_2(),
			       .D_OUT_3(),
			       .D_OUT_4(),
			       .D_OUT_5());

  // rule RL_rl_process_reqs
  assign CAN_FIRE_RL_rl_process_reqs =
	     f_raw_mem_reqs$EMPTY_N &&
	     (f_raw_mem_reqs$D_OUT[315] || f_raw_mem_rsps$FULL_N) ;
  assign WILL_FIRE_RL_rl_process_reqs = CAN_FIRE_RL_rl_process_reqs ;

  // submodule f_raw_mem_reqs
  assign f_raw_mem_reqs$D_IN = request_put ;
  assign f_raw_mem_reqs$ENQ = EN_request_put ;
  assign f_raw_mem_reqs$DEQ = CAN_FIRE_RL_rl_process_reqs ;
  assign f_raw_mem_reqs$CLR = 1'b0 ;

  // submodule f_raw_mem_rsps
  assign f_raw_mem_rsps$D_IN = rf$D_OUT_1 ;
  assign f_raw_mem_rsps$ENQ =
	     WILL_FIRE_RL_rl_process_reqs && !f_raw_mem_reqs$D_OUT[315] ;
  assign f_raw_mem_rsps$DEQ = EN_response_get ;
  assign f_raw_mem_rsps$CLR = 1'b0 ;

  // submodule rf
  assign rf$ADDR_1 = f_raw_mem_reqs$D_OUT[282:256] ;
  assign rf$ADDR_2 = 27'h0 ;
  assign rf$ADDR_3 = 27'h0 ;
  assign rf$ADDR_4 = 27'h0 ;
  assign rf$ADDR_5 = 27'h0 ;
  assign rf$ADDR_IN = f_raw_mem_reqs$D_OUT[282:256] ;
  assign rf$D_IN = f_raw_mem_reqs$D_OUT[255:0] ;
  assign rf$WE = WILL_FIRE_RL_rl_process_reqs && f_raw_mem_reqs$D_OUT[315] ;
endmodule  // mkMem_Model

