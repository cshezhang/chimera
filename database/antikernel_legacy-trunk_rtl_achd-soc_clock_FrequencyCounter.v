`timescale 1ns / 1ps
/***********************************************************************************************************************
*                                                                                                                      *
* ANTIKERNEL v0.1                                                                                                      *
*                                                                                                                      *
* Copyright (c) 2012-2016 Andrew D. Zonenberg                                                                          *
* All rights reserved.                                                                                                 *
*                                                                                                                      *
* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the     *
* following conditions are met:                                                                                        *
*                                                                                                                      *
*    * Redistributions of source code must retain the above copyright notice, this list of conditions, and the         *
*      following disclaimer.                                                                                           *
*                                                                                                                      *
*    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the       *
*      following disclaimer in the documentation and/or other materials provided with the distribution.                *
*                                                                                                                      *
*    * Neither the name of the author nor the names of any contributors may be used to endorse or promote products     *
*      derived from this software without specific prior written permission.                                           *
*                                                                                                                      *
* THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED   *
* TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL *
* THE AUTHORS BE HELD LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES        *
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR       *
* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT *
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE       *
* POSSIBILITY OF SUCH DAMAGE.                                                                                          *
*                                                                                                                      *
***********************************************************************************************************************/

/**
	@file
	@author Andrew D. Zonenberg
	@brief Frequency counter
	
	@module
	@opcodefile		FrequencyCounter_opcodes.constants
	
	@rpcfn			FREQCNT_OP_MEASURE
	@param			itime			{d1[31:0]}:hex					Number of clk_noc cycles to measure over
	@brief			Measure the frequency of the input for the requested number of cycles.
					Note that 32-bit counters are used internally. The results will be incorrect if
					the requested time exceeds 2^32 picoseconds (4.295 ms)
	
	@rpcfn_ok		FREQCNT_OP_MEASURE
	@param			cycles			{d1[31:0]}:dec					Number of cycles observed
	@param			period			{d2[31:0]}:time					Average period, in ps
	@brief			Measurement complete
 */
module FrequencyCounter(
	clk,
	clk_measure,
	rpc_tx_en, rpc_tx_data, rpc_tx_ack, rpc_rx_en, rpc_rx_data, rpc_rx_ack
	);
	
	////////////////////////////////////////////////////////////////////////////////////////////////
	// IO declarations
	
	input wire	clk;
	
	//The clock being measured
	input wire	clk_measure;

	output wire rpc_tx_en;
	output wire[31:0] rpc_tx_data;
	input wire[1:0] rpc_tx_ack;
	input wire rpc_rx_en;
	input wire[31:0] rpc_rx_data;
	output wire[1:0] rpc_rx_ack;
	
	////////////////////////////////////////////////////////////////////////////////////////////////
	// RPC transceiver
	
	`include "RPCv2Router_type_constants.v"	//Pull in autogenerated constant table
	`include "RPCv2Router_ack_constants.v"
	
	parameter NOC_ADDR = 16'h0000;
	
	reg			rpc_master_tx_en 		= 0;
	reg[15:0]	rpc_master_tx_dst_addr	= 0;
	reg[7:0]	rpc_master_tx_callnum	= 0;
	reg[2:0]	rpc_master_tx_type		= 0;
	reg[20:0]	rpc_master_tx_d0		= 0;
	reg[31:0]	rpc_master_tx_d1		= 0;
	reg[31:0]	rpc_master_tx_d2		= 0;
	wire		rpc_master_tx_done;
	
	wire		rpc_master_rx_en;
	wire[15:0]	rpc_master_rx_src_addr;
	wire[15:0]	rpc_master_rx_dst_addr;
	wire[7:0]	rpc_master_rx_callnum;
	wire[2:0]	rpc_master_rx_type;
	wire[20:0]	rpc_master_rx_d0;
	wire[31:0]	rpc_master_rx_d1;
	wire[31:0]	rpc_master_rx_d2;
	reg			rpc_master_rx_done		= 0;
	wire		rpc_master_inbox_full;
	
	reg			rpc_slave_tx_en 		= 0;
	reg[15:0]	rpc_slave_tx_dst_addr	= 0;
	reg[7:0]	rpc_slave_tx_callnum	= 0;
	reg[2:0]	rpc_slave_tx_type		= 0;
	reg[20:0]	rpc_slave_tx_d0			= 0;
	reg[31:0]	rpc_slave_tx_d1			= 0;
	reg[31:0]	rpc_slave_tx_d2			= 0;
	wire		rpc_slave_tx_done;
	
	wire		rpc_slave_rx_en;
	wire[15:0]	rpc_slave_rx_src_addr;
	wire[15:0]	rpc_slave_rx_dst_addr;
	wire[7:0]	rpc_slave_rx_callnum;
	//slave rx type is always RPC_TYPE_CALL
	wire[20:0]	rpc_slave_rx_d0;
	wire[31:0]	rpc_slave_rx_d1;
	wire[31:0]	rpc_slave_rx_d2;
	reg			rpc_slave_rx_done		= 0;
	wire		rpc_slave_inbox_full;
	
	RPCv2MasterSlave #(
		.LEAF_ADDR(NOC_ADDR),
		.DROP_MISMATCH_CALLS(1'b1)
	) rpc_txvr (
		//NoC interface
		.clk(clk),
		.rpc_tx_en(rpc_tx_en),
		.rpc_tx_data(rpc_tx_data),
		.rpc_tx_ack(rpc_tx_ack),
		.rpc_rx_en(rpc_rx_en),
		.rpc_rx_data(rpc_rx_data),
		.rpc_rx_ack(rpc_rx_ack),
		
		//Master interface
		.rpc_master_tx_en(rpc_master_tx_en),
		.rpc_master_tx_dst_addr(rpc_master_tx_dst_addr),
		.rpc_master_tx_callnum(rpc_master_tx_callnum),
		.rpc_master_tx_type(rpc_master_tx_type),
		.rpc_master_tx_d0(rpc_master_tx_d0),
		.rpc_master_tx_d1(rpc_master_tx_d1),
		.rpc_master_tx_d2(rpc_master_tx_d2),
		.rpc_master_tx_done(rpc_master_tx_done),
		
		.rpc_master_rx_en(rpc_master_rx_en),
		.rpc_master_rx_src_addr(rpc_master_rx_src_addr),
		.rpc_master_rx_dst_addr(rpc_master_rx_dst_addr),
		.rpc_master_rx_callnum(rpc_master_rx_callnum),
		.rpc_master_rx_type(rpc_master_rx_type),
		.rpc_master_rx_d0(rpc_master_rx_d0),
		.rpc_master_rx_d1(rpc_master_rx_d1),
		.rpc_master_rx_d2(rpc_master_rx_d2),
		.rpc_master_rx_done(rpc_master_rx_done),
		.rpc_master_inbox_full(rpc_master_inbox_full),
		
		//Slave interface
		.rpc_slave_tx_en(rpc_slave_tx_en),
		.rpc_slave_tx_dst_addr(rpc_slave_tx_dst_addr),
		.rpc_slave_tx_callnum(rpc_slave_tx_callnum),
		.rpc_slave_tx_type(rpc_slave_tx_type),
		.rpc_slave_tx_d0(rpc_slave_tx_d0),
		.rpc_slave_tx_d1(rpc_slave_tx_d1),
		.rpc_slave_tx_d2(rpc_slave_tx_d2),
		.rpc_slave_tx_done(rpc_slave_tx_done),
		
		.rpc_slave_rx_en(rpc_slave_rx_en),
		.rpc_slave_rx_src_addr(rpc_slave_rx_src_addr),
		.rpc_slave_rx_dst_addr(rpc_slave_rx_dst_addr),
		.rpc_slave_rx_callnum(rpc_slave_rx_callnum),
		.rpc_slave_rx_d0(rpc_slave_rx_d0),
		.rpc_slave_rx_d1(rpc_slave_rx_d1),
		.rpc_slave_rx_d2(rpc_slave_rx_d2),
		.rpc_slave_rx_done(rpc_slave_rx_done),
		.rpc_slave_inbox_full(rpc_slave_inbox_full)
	);
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//Synchronizer between input and measurement clock domains
	
	reg		start	= 0;
	wire	start_sync;
	reg		done	= 0;
	wire	done_sync;
	wire	stopped_sync;
	
	HandshakeSynchronizer sync_start(
		.clk_a(clk),			.en_a(start),		.ack_a(),				.busy_a(),
		.clk_b(clk_measure),	.en_b(start_sync),	.ack_b(start_sync));
	
	HandshakeSynchronizer sync_done(
		.clk_a(clk),			.en_a(done),		.ack_a(stopped_sync),	.busy_a(),
		.clk_b(clk_measure),	.en_b(done_sync),	.ack_b(done_sync));
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Measurement clock domain
	
	reg[31:0]	count_measure	= 0;
	reg			counting		= 0;
	
	always @(posedge clk_measure) begin
	
		if(start_sync) begin
			counting		<= 1;
			count_measure	<= 1;
		end
		
		if(done_sync)
			counting		<= 0;
			
		if(counting)
			count_measure	<= count_measure + 32'h1;
	
	end
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Multiplier and divider
	
	reg			divstart = 0;
	wire[31:0]	quot;
	wire[31:0]	rem;
	reg[31:0]	dend	= 0;
	reg[31:0]	dvsr	= 0;
	wire		divdone;
	
	UnsignedNonPipelinedDivider divider(
		.clk(clk),
		.start(divstart),
		.dend(dend),
		.dvsr(dvsr),
		.quot(quot),
		.rem(rem),
		.busy(),
		.done(divdone));
		
	reg			mult_start	= 0;
	reg[31:0]	mult_a		= 0;
	reg[31:0]	mult_b		= 0;
	(* MULT_STYLE = "PIPE_BLOCK" *)
	reg[31:0]	mult_out1	= 0;
	reg[31:0]	mult_out2	= 0;
	reg[31:0]	mult_out3	= 0;
	reg			mult_done1	= 0;
	reg			mult_done2	= 0;
	reg			mult_done3	= 0;
	
	always @(posedge clk) begin
		mult_done1	<= mult_start;
		mult_done2	<= mult_done1;
		mult_done3	<= mult_done2;
		mult_out1	<= mult_a * mult_b;
		mult_out2	<= mult_out1;
		mult_out3	<= mult_out2;
	end
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Main state machine
	
	`include "FrequencyCounter_opcodes_constants.v"	//Pull in autogenerated constant table
	`include "FrequencyCounter_states_constants.v"
	
	`include "NOCNameServer_constants.v"
	`include "NOCSysinfo_constants.v"

	reg[3:0] state = STATE_BOOT_0;
	
	reg[15:0]	sysinfo_addr	= 0;
	reg[31:0]	cycles_left		= 0;
	reg[31:0]	cycles_counted	= 0;
	
	always @(posedge clk) begin
	
		start				<= 0;
		done				<= 0;
		rpc_slave_tx_en		<= 0;
		rpc_master_tx_en	<= 0;
		rpc_slave_rx_done	<= 0;
		rpc_master_rx_done	<= 0;
		divstart			<= 0;
		mult_start			<= 0;
	
		case(state)
		
			////////////////////////////////////////////////////////////////////////////////////////////////////////////
			// Boot-time initialization
		
			//Ask for the address of sysinfo
			STATE_BOOT_0: begin
				rpc_master_tx_en		<= 1;
				rpc_master_tx_dst_addr	<= NAMESERVER_ADDR;
				rpc_master_tx_type		<= RPC_TYPE_CALL;
				rpc_master_tx_callnum	<= NAMESERVER_FQUERY;
				rpc_master_tx_d0		<= 0;
				rpc_master_tx_d1		<= "sysi";
				rpc_master_tx_d2		<= {"nfo", 8'h0};
				state					<= STATE_BOOT_1;
			end	//end STATE_BOOT_0
			
			//Wait for response
			STATE_BOOT_1: begin
				if(rpc_master_inbox_full) begin
				
					//Done, whatever it is
					rpc_master_rx_done	<= 1;
				
					//Retry? Send again
					if(rpc_master_rx_type == RPC_TYPE_RETURN_RETRY)
						state			<= STATE_BOOT_0;
					
					//Save result
					else if(rpc_master_rx_type == RPC_TYPE_RETURN_SUCCESS) begin
						sysinfo_addr	<= rpc_master_rx_d0[15:0];
						state			<= STATE_IDLE;
					end
					
					//Bad lookup, we're screwed
					else
						state			<= STATE_BOOT_HANG;
				
				end
			end	//end STATE_BOOT_1
			
			//Nothing to do, die
			STATE_BOOT_HANG: begin
			end	//end STATE_BOOT_HANG
		
			////////////////////////////////////////////////////////////////////////////////////////////////////////////
			// Sit around and wait for messages
		
			STATE_IDLE: begin
				
				if(rpc_slave_inbox_full) begin
				
					//Default response
					rpc_slave_tx_callnum	<= rpc_slave_rx_callnum;
					rpc_slave_tx_dst_addr	<= rpc_slave_rx_src_addr;
					rpc_slave_tx_d0			<= 0;
					rpc_slave_tx_d1			<= 0;
					rpc_slave_tx_d2			<= 0;
					rpc_slave_tx_type		<= RPC_TYPE_RETURN_FAIL;
					
					//Always done
					rpc_slave_rx_done		<= 1;
					
					//Look up what it is
					case(rpc_slave_rx_callnum)
						
						//just always succeed, do nothing
						FREQCNT_OP_NOP: begin
							rpc_slave_rx_done		<= 1;
							rpc_slave_tx_en			<= 1;
							rpc_slave_tx_type		<= RPC_TYPE_RETURN_SUCCESS;
							state					<= STATE_RPC_TXHOLD;
						end
						
						//Prepare to measure
						FREQCNT_OP_MEASURE: begin
							cycles_left				<= rpc_slave_rx_d1;
							cycles_counted			<= rpc_slave_rx_d1;
							start					<= 1;
							state					<= STATE_MEASURE_0;
						end
						
					endcase
				
				end
				
			end	//end STATE_IDLE
			
			////////////////////////////////////////////////////////////////////////////////////////////////////////////
			// Actual frequency measurement control logic
			
			//Wait till the counter runs down
			STATE_MEASURE_0: begin
				cycles_left	<= cycles_left - 32'h1;
				
				//If we just finished the measurement period, stop
				if(cycles_left == 1) begin
					done	<= 1;
					state	<= STATE_MEASURE_1;
				end
				
			end	//end STATE_MEASURE_0
			
			//Wait till the other end confirm being done
			STATE_MEASURE_1: begin
				if(stopped_sync) begin
				
					//Ask sysinfo what the current clock frequency is
					rpc_master_tx_en		<= 1;
					rpc_master_tx_dst_addr	<= sysinfo_addr;
					rpc_master_tx_type		<= RPC_TYPE_CALL;
					rpc_master_tx_callnum	<= SYSINFO_QUERY_FREQ;
					rpc_master_tx_d0		<= 0;
					rpc_master_tx_d1		<= 0;
					rpc_master_tx_d2		<= 0;
					state					<= STATE_MEASURE_2;
				
					//Save time in cycles in the return message
					rpc_slave_tx_d1		<= count_measure;
					rpc_slave_tx_type	<= RPC_TYPE_RETURN_SUCCESS;

				end
			end	//end STATE_MEASURE_1
			
			//Wait for sysinfo to respond
			STATE_MEASURE_2: begin
				if(rpc_master_inbox_full && !rpc_master_rx_done) begin
				
					//Done, whatever it is
					rpc_master_rx_done	<= 1;
				
					//Retry? Send again
					if(rpc_master_rx_type == RPC_TYPE_RETURN_RETRY)
						rpc_master_tx_en	<= 1;
					
					//Successful? Calculate the actual time elapsed, in ps
					else if(rpc_master_rx_type == RPC_TYPE_RETURN_SUCCESS) begin
						mult_start		<= 1;
						mult_a			<= rpc_master_rx_d1;
						mult_b			<= cycles_counted;
						state			<= STATE_MEASURE_3;
					end
					
					//Bad lookup, we're screwed
					else
						state			<= STATE_BOOT_HANG;
				
				end
			end	//end STATE_MEASURE_2
			
			//We now know the total elasped time, in ps
			//Divide by number of clocks observed to get average period
			STATE_MEASURE_3: begin
				if(mult_done3) begin
					divstart	<= 1;
					dend		<= mult_out3;
					dvsr		<= count_measure;
					state		<= STATE_MEASURE_4;
				end
			end	//end STATE_MEASURE_3
			
			//then send that
			STATE_MEASURE_4: begin
				if(divdone) begin
					rpc_slave_tx_d2		<= quot;
					rpc_slave_tx_en		<= 1;
					state				<= STATE_RPC_TXHOLD;
				end
			end
			
			////////////////////////////////////////////////////////////////////////////////////////////////////////////
			// NoC helpers
			
			STATE_RPC_TXHOLD: begin
				if(rpc_slave_tx_done)
					state		<= STATE_IDLE;
			end	//end STATE_RPC_TXHOLD
			
		endcase
	
	end
	
endmodule
