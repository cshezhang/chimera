`timescale 1ns / 1ps
`default_nettype none
/***********************************************************************************************************************
*                                                                                                                      *
* ANTIKERNEL v0.1                                                                                                      *
*                                                                                                                      *
* Copyright (c) 2012-2016 Andrew D. Zonenberg                                                                          *
* All rights reserved.                                                                                                 *
*                                                                                                                      *
* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the     *
* following conditions are met:                                                                                        *
*                                                                                                                      *
*    * Redistributions of source code must retain the above copyright notice, this list of conditions, and the         *
*      following disclaimer.                                                                                           *
*                                                                                                                      *
*    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the       *
*      following disclaimer in the documentation and/or other materials provided with the distribution.                *
*                                                                                                                      *
*    * Neither the name of the author nor the names of any contributors may be used to endorse or promote products     *
*      derived from this software without specific prior written permission.                                           *
*                                                                                                                      *
* THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED   *
* TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL *
* THE AUTHORS BE HELD LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES        *
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR       *
* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT *
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE       *
* POSSIBILITY OF SUCH DAMAGE.                                                                                          *
*                                                                                                                      *
***********************************************************************************************************************/

/**
	@file
	@author Andrew D. Zonenberg
	@brief Wrapper around NativeTrueRNG
 */
module NetworkedTrueRNG(
	
	//Clocks
	clk,
	
	//NoC interface
	rpc_tx_en, rpc_tx_data, rpc_tx_ack, rpc_rx_en, rpc_rx_data, rpc_rx_ack,
	dma_tx_en, dma_tx_data, dma_tx_ack, dma_rx_en, dma_rx_data, dma_rx_ack
	);
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// I/O declarations
	
	//Clocks
	input wire clk;

	//NoC interface
	output wire rpc_tx_en;
	output wire[31:0] rpc_tx_data;
	input wire[1:0] rpc_tx_ack;
	input wire rpc_rx_en;
	input wire[31:0] rpc_rx_data;
	output wire[1:0] rpc_rx_ack;
	
	output wire dma_tx_en;
	output wire[31:0] dma_tx_data;
	input wire dma_tx_ack;
	input wire dma_rx_en;
	input wire[31:0] dma_rx_data;
	output wire dma_rx_ack;

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// NoC transceivers
	
	`include "DMARouter_constants.v"
	`include "RPCv2Router_type_constants.v"	//Pull in autogenerated constant table
	`include "RPCv2Router_ack_constants.v"
	
	parameter NOC_ADDR = 16'h0000;
	
	reg			rpc_fab_tx_en 		= 0;
	reg[15:0]	rpc_fab_tx_dst_addr	= 0;
	reg[7:0]	rpc_fab_tx_callnum	= 0;
	reg[2:0]	rpc_fab_tx_type		= 0;
	reg[20:0]	rpc_fab_tx_d0		= 0;
	reg[31:0]	rpc_fab_tx_d1		= 0;
	reg[31:0]	rpc_fab_tx_d2		= 0;
	wire		rpc_fab_tx_done;
	
	wire		rpc_fab_rx_en;
	wire[15:0]	rpc_fab_rx_src_addr;
	wire[15:0]	rpc_fab_rx_dst_addr;
	wire[7:0]	rpc_fab_rx_callnum;
	wire[2:0]	rpc_fab_rx_type;
	wire[20:0]	rpc_fab_rx_d0;
	wire[31:0]	rpc_fab_rx_d1;
	wire[31:0]	rpc_fab_rx_d2;
	reg			rpc_fab_rx_done		= 0;
	wire		rpc_fab_inbox_full;
	
	RPCv2Transceiver #(
		.LEAF_PORT(1),
		.LEAF_ADDR(NOC_ADDR)
	) txvr(
		.clk(clk),
		
		.rpc_tx_en(rpc_tx_en),
		.rpc_tx_data(rpc_tx_data),
		.rpc_tx_ack(rpc_tx_ack),
		
		.rpc_rx_en(rpc_rx_en),
		.rpc_rx_data(rpc_rx_data),
		.rpc_rx_ack(rpc_rx_ack),
		
		.rpc_fab_tx_en(rpc_fab_tx_en),
		.rpc_fab_tx_src_addr(16'h0000),
		.rpc_fab_tx_dst_addr(rpc_fab_tx_dst_addr),
		.rpc_fab_tx_callnum(rpc_fab_tx_callnum),
		.rpc_fab_tx_type(rpc_fab_tx_type),
		.rpc_fab_tx_d0(rpc_fab_tx_d0),
		.rpc_fab_tx_d1(rpc_fab_tx_d1),
		.rpc_fab_tx_d2(rpc_fab_tx_d2),
		.rpc_fab_tx_done(rpc_fab_tx_done),
		
		.rpc_fab_rx_en(rpc_fab_rx_en),
		.rpc_fab_rx_src_addr(rpc_fab_rx_src_addr),
		.rpc_fab_rx_dst_addr(rpc_fab_rx_dst_addr),
		.rpc_fab_rx_callnum(rpc_fab_rx_callnum),
		.rpc_fab_rx_type(rpc_fab_rx_type),
		.rpc_fab_rx_d0(rpc_fab_rx_d0),
		.rpc_fab_rx_d1(rpc_fab_rx_d1),
		.rpc_fab_rx_d2(rpc_fab_rx_d2),
		.rpc_fab_rx_done(rpc_fab_rx_done),
		.rpc_fab_inbox_full(rpc_fab_inbox_full)
		);
	
	//DMA transmit signals
	wire dtx_busy;
	reg[15:0] dtx_dst_addr = 0;
	reg[1:0] dtx_op = 0;
	reg[9:0] dtx_len = 0;
	reg[31:0] dtx_addr = 0;
	reg dtx_en = 0;
	wire dtx_rd;
	wire[9:0] dtx_raddr;
	reg[31:0] dtx_buf_out = 0;
	
	//DMA receive signals
	reg drx_ready = 1;
	wire drx_en;
	wire[15:0] drx_src_addr;
	wire[15:0] drx_dst_addr;
	wire[1:0] drx_op;
	wire[31:0] drx_addr;
	wire[9:0] drx_len;	
	
	//DMA transceiver
	DMATransceiver #(
		.LEAF_PORT(1),
		.LEAF_ADDR(NOC_ADDR)
	) dma_txvr(
		.clk(clk),
		.dma_tx_en(dma_tx_en), .dma_tx_data(dma_tx_data), .dma_tx_ack(dma_tx_ack),
		.dma_rx_en(dma_rx_en), .dma_rx_data(dma_rx_data), .dma_rx_ack(dma_rx_ack),
		
		.tx_done(),
		.tx_busy(dtx_busy), .tx_src_addr(16'h0000), .tx_dst_addr(dtx_dst_addr), .tx_op(dtx_op), .tx_len(dtx_len),
		.tx_addr(dtx_addr), .tx_en(dtx_en), .tx_rd(dtx_rd), .tx_raddr(dtx_raddr), .tx_buf_out(dtx_buf_out),
		
		.rx_ready(drx_ready), .rx_en(drx_en), .rx_src_addr(drx_src_addr), .rx_dst_addr(drx_dst_addr),
		.rx_op(drx_op), .rx_addr(drx_addr), .rx_len(drx_len),
		.rx_buf_rd(1'b0), .rx_buf_addr(9'b0), .rx_buf_data(), .rx_buf_rdclk(clk)	//we never receive DMA messages
		);
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// The actual RNG
	
	reg rng_reset = 0;
	wire rng_dout;
	wire rng_valid;
	NativeTrueRNG rng(
		.clk(clk),
		.reset(rng_reset),
		.valid(rng_valid),
		.dout(rng_dout)
		);
		
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// SHA256 hash unit for entropy distillation

	reg hash_reset = 0;
	wire hash_resetdone;
	reg hash_we = 0;
	reg[31:0] hash_din = 0;
	reg hash_blockend = 0;
	wire hash_blockdone;
	reg hash_finish = 0;
	wire hash_done;
	wire[31:0] hash_dout;

	AreaOptimizedSHA256 hasher(
		.clk(clk),
		.reset(hash_reset),
		.resetdone(hash_resetdone),
		.we(hash_we),
		.din(hash_din),
		.blockend(hash_blockend),
		.blockdone(hash_blockdone),
		.finish(hash_finish),
		.done(hash_done),
		.dout(hash_dout)
	);
		
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Bit twiddling to get 32-bit words

	//Write control stuff
	reg[31:0] rng_row_buf = 0;
	reg[4:0] rng_bitcount = 0;
	reg rng_row_ready = 0;
	always @(posedge clk) begin
	
		rng_row_ready <= 0;
			
		//Data ready to push?
		if(rng_valid) begin
		
			//Push into the shreg
			rng_bitcount <= rng_bitcount + 5'h1;
			rng_row_buf <= {rng_row_buf[30:0], rng_dout};
		
			//If we just got the last bit of the word, flag the word as ready
			if(rng_bitcount == 31) begin
				rng_bitcount <= 0;
				rng_row_ready <= 1;
			end
		end
		
	end
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// RNG output buffering
	
	//The actual memory
	reg[31:0] output_buffer[511:0];
	integer i;
	initial begin
		for(i=0; i<512; i = i+1)
			output_buffer[i] = 32'hc0dec0de;
	end
	
	//Transmit logic
	always @(posedge clk) begin
		if(dtx_rd)
			dtx_buf_out <= output_buffer[dtx_raddr[8:0]];
	end
	
	//Write logic
	reg output_buf_we = 0;
	reg[8:0] output_buf_waddr = 0;
	reg[31:0] output_buf_din = 0;
	always @(posedge clk) begin
		if(output_buf_we)
			output_buffer[output_buf_waddr] <= output_buf_din;
	end
	
	//Indicates a buffer is ready to read
	reg buffer_ready = 0;
	always @(posedge clk) begin
		if(output_buf_we && (output_buf_waddr == 'd511))
			buffer_ready <= 1;
		if(buffer_reset)
			buffer_ready <= 0;
	end
	
	reg buffer_reset = 0;
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// State machine for hash control
	
	`include "NetworkedTrueRNG_hashstates_constants.v"
		
	reg[3:0] hashstate = HASH_STATE_RESET;
	reg[4:0] wordcount = 0;
	reg[2:0] blockcount = 0;
	reg[2:0] writeback_count = 0;
	always @(posedge clk) begin
	
		hash_we <= 0;
		hash_reset <= 0;
		hash_blockend <= 0;
		hash_finish <= 0;
		output_buf_we <= 0;
		
		//Bump address after a write so we're ready for the next one
		if(output_buf_we)
			output_buf_waddr <= output_buf_waddr + 9'h1;
		
		case(hashstate)
			
			////////////////////////////////////////////////////////////////////////////////////////////////////////////
			// Reset logic
			
			HASH_STATE_RESET: begin
				wordcount <= 0;
				blockcount <= 0;
				hash_reset <= 1;
				hashstate <= HASH_STATE_RESET_WAIT;
			end	//end HASH_STATE_RESET
			
			HASH_STATE_RESET_WAIT: begin
				if(hash_resetdone)
					hashstate <= HASH_STATE_APPEND;
			end	//end HASH_STATE_RESET_WAIT
			
			////////////////////////////////////////////////////////////////////////////////////////////////////////////
			// Hashing
			
			//Append a new word to the current hash state
			HASH_STATE_APPEND: begin
				
				if(rng_row_ready) begin
					hash_we <= 1;
					hash_din <= rng_row_buf;
					wordcount <= wordcount + 4'h1;
					
					//Done with the block?
					if(wordcount == 15) begin									
						hash_blockend <= 1;
						hashstate <= HASH_STATE_APPEND_WAIT;
						
						//If we're also done with the entire chunk, we need to do something else!
						blockcount <= blockcount + 3'h1;
						if(blockcount == 3'h7) begin
							hash_finish <= 1;
							hashstate <= HASH_STATE_DONE_WAIT;
						end
					end
					
				end
				
			end	//end HASH_STATE_APPEND
			
			//Wait for the hashing to finish, then go back and feed more random data in
			HASH_STATE_APPEND_WAIT: begin
				if(hash_blockdone)
					hashstate <= HASH_STATE_APPEND;
			end	//end HASH_STATE_APPEND_WAIT
			
			HASH_STATE_DONE_WAIT: begin
				if(hash_done) begin
					hashstate <= HASH_STATE_WRITEBACK;
					writeback_count <= 0;
					
					output_buf_we <= 1;				//Write the first word immediately
					output_buf_din <= hash_dout;
				end
			end	//end HASH_STATE_DONE_WAIT
			
			////////////////////////////////////////////////////////////////////////////////////////////////////////////
			// Writeback logic
			
			HASH_STATE_WRITEBACK: begin
				output_buf_we <= 1;
				output_buf_din <= hash_dout;
				writeback_count <= writeback_count + 3'h1;

				if(writeback_count == 6) begin
					output_buf_din <= hash_dout[31:0];
					
					//If we're about to write the last word of the buffer, go on and wait for it to be done
					if(output_buf_waddr == 'd511)
						hashstate <= HASH_STATE_WRITEBACK_WAIT;		
						
					//Otherwise start feeding more stuff into the hash context
					else
						hashstate <= HASH_STATE_APPEND;
				end
			end	//end HASH_STATE_WRITEBACK
			
			HASH_STATE_WRITEBACK_WAIT: begin
				if(buffer_reset)
					hashstate <= HASH_STATE_RESET;
			end	//end HASH_STATE_WRITEBACK_WAIT
			
		endcase
		
		if(rng_reset)
			hashstate <= HASH_STATE_RESET;
	end

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Interface state machine
	
	`include "NetworkedTrueRNG_opcodes_constants.v"
	`include "NetworkedTrueRNG_states_constants.v"
	
	reg dma_message_pending = 0;
	
	reg[3:0] state = STATE_IDLE;
	
	always @(posedge clk) begin
		
		rng_reset <= 0;
		rpc_fab_tx_en <= 0;
		buffer_reset <= 0;
		dtx_en <= 0;
	
		//Save flags
		if(drx_en)
			dma_message_pending <= 1;
			
		case(state)
			STATE_IDLE: begin
			
				//RPC stuff
				if(rpc_fab_inbox_full) begin
					
					case(rpc_fab_rx_type)
						RPC_TYPE_CALL: begin
						
							//Save parameters
							rpc_fab_tx_dst_addr <= rpc_fab_rx_src_addr;
							rpc_fab_tx_callnum <= rpc_fab_rx_callnum;
						
							case(rpc_fab_rx_callnum)
							
								//Reset the ring oscillator
								RNG_OP_RESET: begin
									rng_reset <= 1;
									buffer_reset <= 1;
									
									rpc_fab_tx_type <= RPC_TYPE_RETURN_SUCCESS;
									rpc_fab_tx_d0 <= 0;
									rpc_fab_tx_d1 <= 0;
									rpc_fab_tx_d2 <= 0;
									rpc_fab_tx_en <= 1;
									state <= STATE_RPC_TXHOLD;
									
									rpc_fab_rx_done <= 1;
								end	//end RNG_OP_RESET
								
								default: begin
								
									rpc_fab_tx_type <= RPC_TYPE_RETURN_FAIL;
									rpc_fab_tx_d0 <= 0;
									rpc_fab_tx_d1 <= 0;
									rpc_fab_tx_d2 <= 0;
									rpc_fab_tx_en <= 1;
									state <= STATE_RPC_TXHOLD;
								
									rpc_fab_rx_done <= 1;
								end
								
							endcase
						end	//end RPC_FAB_RX_CALL
						
						default: begin
							rpc_fab_rx_done <= 1;
						end
					endcase
				end
				
				else if(drx_en || dma_message_pending) begin
					
					drx_ready <= 0;
					dma_message_pending <= 0;
					
					//default response stuff
					dtx_addr <= drx_addr;
					dtx_dst_addr <= drx_src_addr;
					dtx_len <= drx_len;
					
					//DMA stuff
					case(drx_op)
						DMA_OP_READ_REQUEST: begin
							state <= STATE_WAIT_FOR_DATA;
						end
						
						default: begin
							//ignore
							drx_ready <= 1;
						end
					endcase
					
				end
			
			end	//end STATE_IDLE
			
			STATE_RPC_TXHOLD: begin
				if(rpc_fab_tx_done)
					state <= STATE_IDLE;
			end	//end STATE_RPC_TXHOLD
			
			STATE_DMA_TXHOLD: begin
				if(!dtx_en && !dtx_busy) begin
					state <= STATE_WAIT_FOR_RESET;
					buffer_reset <= 1;
				end
			end	//end STATE_DMA_TXHOLD
			
			STATE_WAIT_FOR_RESET: begin
				if(!buffer_ready) begin
					state <= STATE_IDLE;
					drx_ready <= 1;
				end
			end	//end STATE_WAIT_FOR_RESET
			
			STATE_WAIT_FOR_DATA: begin
				if(buffer_ready) begin
					dtx_op <= DMA_OP_READ_DATA;
					dtx_en <= 1;
					state <= STATE_DMA_TXHOLD;
				end
			end	//end STATE_WAIT_FOR_DATA
			
		endcase		
	end	

endmodule
