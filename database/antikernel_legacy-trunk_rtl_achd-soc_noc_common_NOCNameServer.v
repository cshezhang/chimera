`timescale 1ns / 1ps
`default_nettype none
/***********************************************************************************************************************
*                                                                                                                      *
* ANTIKERNEL v0.1                                                                                                      *
*                                                                                                                      *
* Copyright (c) 2012-2016 Andrew D. Zonenberg                                                                          *
* All rights reserved.                                                                                                 *
*                                                                                                                      *
* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the     *
* following conditions are met:                                                                                        *
*                                                                                                                      *
*    * Redistributions of source code must retain the above copyright notice, this list of conditions, and the         *
*      following disclaimer.                                                                                           *
*                                                                                                                      *
*    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the       *
*      following disclaimer in the documentation and/or other materials provided with the distribution.                *
*                                                                                                                      *
*    * Neither the name of the author nor the names of any contributors may be used to endorse or promote products     *
*      derived from this software without specific prior written permission.                                           *
*                                                                                                                      *
* THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED   *
* TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL *
* THE AUTHORS BE HELD LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES        *
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR       *
* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT *
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE       *
* POSSIBILITY OF SUCH DAMAGE.                                                                                          *
*                                                                                                                      *
***********************************************************************************************************************/

/**
	@file
	@author Andrew D. Zonenberg
	@brief Name server for NoC
	
	By convention, this module is always located at RPC network address 0x8000.
	
	Intended to be used during boot / application startup / debugging only, there is no focus on performance in this
	implementation.
	
	The first occurrence of an 0x00 byte, if matched in both strings, stops the comparison.
	
	Certain operations (name registration) require a HMAC-SHA256 signature. The signature is calculated over the
	entire message packet as a 128-bit binary blob. The key is a 512-bit binary blob generated by SHA512 of an
	arbitrarily long password.
	
	@module
	@opcodefile		NOCNameServer.constants
	
	@rpcfn			NAMESERVER_LIST
	@brief			Enumerate all of the cache slots. Used by PC-side code to do host enumeration.
	@param			cache_index		d0[31:0]:dec			Cache line number
	
	@rpcfn_ok		NAMESERVER_LIST
	@brief			Valid cache line
	@param			addr			d0[15:0]:nocaddr				Routing address of the host
	@param			hostname		{d1[31:0],d2[31:0]}:asciiz		Name of the host
	
	@rpcfn_fail		NAMESERVER_LIST
	@brief			Cache line is empty.
	
	@rpcfn			NAMESERVER_FQUERY
	@brief			Looks up the address for a given hostname.
	@param			hostname		{d1[31:0],d2[31:0]}:asciiz		Name of the host
	
	@rpcfn_ok		NAMESERVER_FQUERY
	@brief			Address found.
	@param			addr			d0[15:0]:nocaddr				Routing address of the host
	
	@rpcfn_fail		NAMESERVER_FQUERY
	@brief			Host not found.
	
	@rpcfn			NAMESERVER_RQUERY
	@brief			Searches for the hostname corresponding to a given address.
	
	@rpcfn_ok		NAMESERVER_RQUERY
	@brief			Hostname found.
	@param			hostname		{d1[31:0],d2[31:0]}:asciiz		Name of the host
	
	@rpcfn_fail		NAMESERVER_RQUERY
	@brief			Address not found.
	
	@rpcfn			NAMESERVER_LOCK
	@brief			Acquire the write mutex
	
	@rpcfn_ok		NAMESERVER_LOCK
	@brief			Write mutex granted for 2^20 clocks
	
	@rpcfn_fail		NAMESERVER_LOCK
	@brief			Write mutex already owned by someone else
	
	@rpcfn			NAMESERVER_HMAC
	@brief			One block of the HMAC signature for a pending request
	@param			blocknum		d0[3:0]:dec						Block number
	@param			hmac			{d1[31:0],d2[31:0]}:hex			HMAC signature blob
	
	@rpcfn_ok		NAMESERVER_HMAC
	@brief			HMAC block accepted
	
	@rpcfn			NAMESERVER_REGISTER
	@brief			Request name registration
	@param			hostname		{d1[31:0],d2[31:0]}:asciiz		Name of the host
	
	@rpcfn_ok		NAMESERVER_REGISTER
	@brief			Name registration successful
	
	@rpcfn_fail		NAMESERVER_REGISTER
	@brief			Name registration failed
	@param			errcode		d0[7:0]:enum						NOCNameServer_failcodes.constants
 */
module NOCNameServer(
	clk,
	rpc_tx_en, rpc_tx_data, rpc_tx_ack, rpc_rx_en, rpc_rx_data, rpc_rx_ack
	);
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// IO / parameter declarations
	
	input wire clk;

	output wire			rpc_tx_en;
	output wire[31:0]	rpc_tx_data;
	input wire[1:0]		rpc_tx_ack;
	input wire			rpc_rx_en;
	input wire[31:0]	rpc_rx_data;
	output wire[1:0]	rpc_rx_ack;
	
	parameter			addr_mem_file = "";
	parameter			host_mem_file = "";
	
	parameter READ_ONLY		= 1'b0;	//enable to make nameserver read only and smaller
	
	parameter HMAC_KEY_0	= 32'h00000000;
	parameter HMAC_KEY_1	= 32'h00000000;
	parameter HMAC_KEY_2	= 32'h00000000;
	parameter HMAC_KEY_3	= 32'h00000000;
	parameter HMAC_KEY_4	= 32'h00000000;
	parameter HMAC_KEY_5	= 32'h00000000;
	parameter HMAC_KEY_6	= 32'h00000000;
	parameter HMAC_KEY_7	= 32'h00000000;
	parameter HMAC_KEY_8	= 32'h00000000;
	parameter HMAC_KEY_9	= 32'h00000000;
	parameter HMAC_KEY_A	= 32'h00000000;
	parameter HMAC_KEY_B	= 32'h00000000;
	parameter HMAC_KEY_C	= 32'h00000000;
	parameter HMAC_KEY_D	= 32'h00000000;
	parameter HMAC_KEY_E	= 32'h00000000;
	parameter HMAC_KEY_F	= 32'h00000000;
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Main memory blocks
	
	//Address and control registers
	wire			rd_en;
	wire[7:0]		rd_ptr;
	wire 			wr_en;
	wire[7:0]		wr_ptr;
	
	wire[15:0]		addr_out;
	wire[63:0]		host_out;
	
	MemoryMacro #(
		.WIDTH(16),
		.DEPTH(256),
		.DUAL_PORT(1),
		.TRUE_DUAL(0),
		.USE_BLOCK(1),
		.OUT_REG(1),
		.INIT_ADDR(0),
		.INIT_FILE(addr_mem_file)
	) addr_mem (
		.porta_clk(clk),
		.porta_en(wr_en),
		.porta_addr(wr_ptr),
		.porta_we(wr_en),
		.porta_din(rpc_fab_rx_src_addr),
		.porta_dout(),
		
		.portb_clk(clk),
		.portb_en(rd_en),
		.portb_addr(rd_ptr),
		.portb_we(1'b0),
		.portb_din(16'h0),
		.portb_dout(addr_out)
	);
	
	MemoryMacro #(
		.WIDTH(64),
		.DEPTH(256),
		.DUAL_PORT(1),
		.TRUE_DUAL(0),
		.USE_BLOCK(1),
		.OUT_REG(1),
		.INIT_ADDR(0),
		.INIT_FILE(host_mem_file)
	) host_mem (
		.porta_clk(clk),
		.porta_en(wr_en),
		.porta_addr(wr_ptr),
		.porta_we(wr_en),
		.porta_din({rpc_fab_rx_d1, rpc_fab_rx_d2}),
		.porta_dout(),
		
		.portb_clk(clk),
		.portb_en(rd_en),
		.portb_addr(rd_ptr),
		.portb_we(1'b0),
		.portb_din(64'h0),
		.portb_dout(host_out)
	);

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// RPC transceiver
	
	parameter NOC_ADDR = 16'h0000;
	
	wire		rpc_fab_tx_en;
	wire[15:0]	rpc_fab_tx_dst_addr;
	wire[7:0]	rpc_fab_tx_callnum;
	wire[2:0]	rpc_fab_tx_type;
	wire[20:0]	rpc_fab_tx_d0;
	wire[31:0]	rpc_fab_tx_d1;
	wire[31:0]	rpc_fab_tx_d2;
	wire		rpc_fab_tx_done;
	
	wire		rpc_fab_rx_en;
	wire[15:0]	rpc_fab_rx_src_addr;
	wire[15:0]	rpc_fab_rx_dst_addr;
	wire[7:0]	rpc_fab_rx_callnum;
	wire[2:0]	rpc_fab_rx_type;
	wire[20:0]	rpc_fab_rx_d0;
	wire[31:0]	rpc_fab_rx_d1;
	wire[31:0]	rpc_fab_rx_d2;
	wire		rpc_fab_rx_done;
	
	//loop back destination address
	assign		rpc_fab_tx_dst_addr	= rpc_fab_rx_src_addr;
	
	RPCv2Transceiver #(
		.LEAF_PORT(1),
		.LEAF_ADDR(NOC_ADDR)
	) txvr(
		.clk(clk),
		
		.rpc_tx_en(rpc_tx_en),
		.rpc_tx_data(rpc_tx_data),
		.rpc_tx_ack(rpc_tx_ack),
		
		.rpc_rx_en(rpc_rx_en),
		.rpc_rx_data(rpc_rx_data),
		.rpc_rx_ack(rpc_rx_ack),
		
		.rpc_fab_tx_en(rpc_fab_tx_en),
		.rpc_fab_tx_src_addr(16'h0000),
		.rpc_fab_tx_dst_addr(rpc_fab_tx_dst_addr),
		.rpc_fab_tx_callnum(rpc_fab_tx_callnum),
		.rpc_fab_tx_type(rpc_fab_tx_type),
		.rpc_fab_tx_d0(rpc_fab_tx_d0),
		.rpc_fab_tx_d1(rpc_fab_tx_d1),
		.rpc_fab_tx_d2(rpc_fab_tx_d2),
		.rpc_fab_tx_done(rpc_fab_tx_done),
		
		.rpc_fab_rx_en(rpc_fab_rx_en),
		.rpc_fab_rx_src_addr(rpc_fab_rx_src_addr),
		.rpc_fab_rx_dst_addr(rpc_fab_rx_dst_addr),
		.rpc_fab_rx_callnum(rpc_fab_rx_callnum),
		.rpc_fab_rx_type(rpc_fab_rx_type),
		.rpc_fab_rx_d0(rpc_fab_rx_d0),
		.rpc_fab_rx_d1(rpc_fab_rx_d1),
		.rpc_fab_rx_d2(rpc_fab_rx_d2),
		.rpc_fab_rx_done(rpc_fab_rx_done),
		.rpc_fab_inbox_full()
		);

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// HMAC module for checking registration requests
	
	wire		hmac_start_en;
	wire		hmac_data_en;
	wire		hmac_finish_en;
	wire[31:0]	hmac_din;
	wire		hmac_done;
	wire		hmac_dout_valid;
	wire[31:0]	hmac_dout;
	
	generate
		if(READ_ONLY) begin
			assign hmac_done		= 0;
			assign hmac_dout_valid	= 0;
			assign hmac_dout		= 0;
		end
		
		else begin
			HMACSHA256SignatureChecker #(
				.KEY_0(HMAC_KEY_0),
				.KEY_1(HMAC_KEY_1),
				.KEY_2(HMAC_KEY_2),
				.KEY_3(HMAC_KEY_3),
				.KEY_4(HMAC_KEY_4),
				.KEY_5(HMAC_KEY_5),
				.KEY_6(HMAC_KEY_6),
				.KEY_7(HMAC_KEY_7),
				.KEY_8(HMAC_KEY_8),
				.KEY_9(HMAC_KEY_9),
				.KEY_A(HMAC_KEY_A),
				.KEY_B(HMAC_KEY_B),
				.KEY_C(HMAC_KEY_C),
				.KEY_D(HMAC_KEY_D),
				.KEY_E(HMAC_KEY_E),
				.KEY_F(HMAC_KEY_F)
			) hmac (
				.clk(clk),
				.start_en(hmac_start_en),
				.data_en(hmac_data_en),
				.finish_en(hmac_finish_en),
				.din(hmac_din),
				.done(hmac_done),
				.dout_valid(hmac_dout_valid),
				.dout(hmac_dout)
			);
		end
	endgenerate
			
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Buffer for storing the target HMAC
	
	wire		hmac_mem_wr;
	wire[3:0]	hmac_mem_addr;
	wire[31:0]	hmac_mem_din;
	wire[31:0]	hmac_mem_dout;
	
	generate
		if(READ_ONLY) begin
			assign hmac_mem_dout = 0;
		end
		else begin
			MemoryMacro #(
				.WIDTH(32),
				.DEPTH(8),
				.DUAL_PORT(0),
				.TRUE_DUAL(0),
				.USE_BLOCK(0),
				.OUT_REG(0),
				.INIT_ADDR(0),
				.INIT_FILE("")
			) hmac_mem (
				.porta_clk(clk),
				.porta_en(1'b1),
				.porta_addr(hmac_mem_addr[2:0]),
				.porta_we(hmac_mem_wr),
				.porta_din(hmac_mem_din),
				.porta_dout(hmac_mem_dout),
				.portb_clk(clk),
				.portb_en(1'b0),
				.portb_addr(3'h0),
				.portb_we(1'b0),
				.portb_din(32'h0),
				.portb_dout()
			);
		end
	endgenerate
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Target matching and pipeline registers
	
	wire[63:0]	host_out_ff;
	wire[15:0]	addr_out_ff;
	
	wire[15:0]	target_addr;
	wire[63:0]	target_host;
	
	wire		host_hit;
	wire		addr_hit;
	
	NOCNameServer_TargetMatching matcher(
		.clk(clk),
		
		.host_out(host_out),
		.addr_out(addr_out),
		.host_out_ff(host_out_ff),
		.addr_out_ff(addr_out_ff),
		
		.target_host(target_host),
		.target_addr(target_addr),
		
		.host_hit(host_hit),
		.addr_hit(addr_hit)
	);
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// The HMAC mutex

	wire	mutex_owned;
	wire	mutex_granted;
	wire	mutex_lock_en;
	wire	mutex_unlock_en;
	
	generate
		if(READ_ONLY) begin
			assign mutex_owned = 0;
			assign mutex_granted = 0;
		end

		else begin
			Mutex #(
				.TIMEOUT_EN(1),
				.TIMEOUT_VAL(32'h00100000)
			) hmac_mutex (
				.clk(clk),
				.test_host(rpc_fab_rx_src_addr),
				.test_owned(mutex_owned),
				.test_granted(mutex_granted),
				.lock_en(mutex_lock_en),
				.unlock_en(mutex_unlock_en)
			);
		end
	endgenerate
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Main state machine
	
	NOCNameServer_control #(
		.READ_ONLY(READ_ONLY)
	) control(
		.clk(clk),
		
		.rd_en(rd_en),
		.rd_ptr(rd_ptr),
		.wr_en(wr_en),
		.wr_ptr(wr_ptr),
		
		.mutex_owned(mutex_owned),
		.mutex_granted(mutex_granted),
		.mutex_lock_en(mutex_lock_en),
		.mutex_unlock_en(mutex_unlock_en),
		
		.host_out_ff(host_out_ff),
		.addr_out_ff(addr_out_ff),
		
		.target_host(target_host),
		.target_addr(target_addr),
		
		.host_hit(host_hit),
		.addr_hit(addr_hit),
		
		.hmac_mem_wr(hmac_mem_wr),
		.hmac_mem_addr(hmac_mem_addr),
		.hmac_mem_din(hmac_mem_din),
		.hmac_mem_dout(hmac_mem_dout),
		
		.hmac_start_en(hmac_start_en),
		.hmac_data_en(hmac_data_en),
		.hmac_finish_en(hmac_finish_en),
		.hmac_din(hmac_din),
		.hmac_done(hmac_done),
		.hmac_dout_valid(hmac_dout_valid),
		.hmac_dout(hmac_dout),
		
		.rpc_fab_tx_en(rpc_fab_tx_en),
		.rpc_fab_tx_callnum(rpc_fab_tx_callnum),
		.rpc_fab_tx_type(rpc_fab_tx_type),
		.rpc_fab_tx_d0(rpc_fab_tx_d0),
		.rpc_fab_tx_d1(rpc_fab_tx_d1),
		.rpc_fab_tx_d2(rpc_fab_tx_d2),
		.rpc_fab_tx_done(rpc_fab_tx_done),
		
		.rpc_fab_rx_en(rpc_fab_rx_en),
		.rpc_fab_rx_src_addr(rpc_fab_rx_src_addr),
		.rpc_fab_rx_dst_addr(rpc_fab_rx_dst_addr),
		.rpc_fab_rx_callnum(rpc_fab_rx_callnum),
		.rpc_fab_rx_type(rpc_fab_rx_type),
		.rpc_fab_rx_d0(rpc_fab_rx_d0),
		.rpc_fab_rx_d1(rpc_fab_rx_d1),
		.rpc_fab_rx_d2(rpc_fab_rx_d2),
		.rpc_fab_rx_done(rpc_fab_rx_done)
		);
	
endmodule
