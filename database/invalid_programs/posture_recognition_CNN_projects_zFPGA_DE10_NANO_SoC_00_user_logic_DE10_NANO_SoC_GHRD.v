
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================
`include "vga_config.inc"
module DE10_NANO_SoC_GHRD(

	//////////// ADC //////////
	output		          		ADC_CONVST,
	output		          		ADC_SCK,
	output		          		ADC_SDI,
	input 		          		ADC_SDO,

	//////////// ARDUINO //////////
	inout 		    [15:0]		ARDUINO_IO,
	inout 		          		ARDUINO_RESET_N,

	//////////// CLOCK //////////
	input 		          		FPGA_CLK1_50,
	input 		          		FPGA_CLK2_50,
	input 		          		FPGA_CLK3_50,

	//////////// HDMI //////////
	inout 		          		HDMI_I2C_SCL,
	inout 		          		HDMI_I2C_SDA,
	inout 		          		HDMI_I2S,
	inout 		          		HDMI_LRCLK,
	inout 		          		HDMI_MCLK,
	inout 		          		HDMI_SCLK,
	output		          		HDMI_TX_CLK,
	output		          		HDMI_TX_DE,
	output		    [23:0]		HDMI_TX_D,
	output		          		HDMI_TX_HS,
	input 		          		HDMI_TX_INT,
	output		          		HDMI_TX_VS,

	//////////// HPS //////////
	inout 		          		HPS_CONV_USB_N,
	output		    [14:0]		HPS_DDR3_ADDR,
	output		     [2:0]		HPS_DDR3_BA,
	output		          		HPS_DDR3_CAS_N,
	output		          		HPS_DDR3_CKE,
	output		          		HPS_DDR3_CK_N,
	output		          		HPS_DDR3_CK_P,
	output		          		HPS_DDR3_CS_N,
	output		     [3:0]		HPS_DDR3_DM,
	inout 		    [31:0]		HPS_DDR3_DQ,
	inout 		     [3:0]		HPS_DDR3_DQS_N,
	inout 		     [3:0]		HPS_DDR3_DQS_P,
	output		          		HPS_DDR3_ODT,
	output		          		HPS_DDR3_RAS_N,
	output		          		HPS_DDR3_RESET_N,
	input 		          		HPS_DDR3_RZQ,
	output		          		HPS_DDR3_WE_N,
	output		          		HPS_ENET_GTX_CLK,
	inout 		          		HPS_ENET_INT_N,
	output		          		HPS_ENET_MDC,
	inout 		          		HPS_ENET_MDIO,
	input 		          		HPS_ENET_RX_CLK,
	input 		     [3:0]		HPS_ENET_RX_DATA,
	input 		          		HPS_ENET_RX_DV,
	output		     [3:0]		HPS_ENET_TX_DATA,
	output		          		HPS_ENET_TX_EN,
	inout 		          		HPS_GSENSOR_INT,
	inout 		          		HPS_I2C0_SCLK,
	inout 		          		HPS_I2C0_SDAT,
	inout 		          		HPS_I2C1_SCLK,
	inout 		          		HPS_I2C1_SDAT,
	inout 		          		HPS_KEY,
	inout 		          		HPS_LED,
	inout 		          		HPS_LTC_GPIO,
	output		          		HPS_SD_CLK,
	inout 		          		HPS_SD_CMD,
	inout 		     [3:0]		HPS_SD_DATA,
	output		          		HPS_SPIM_CLK,
	input 		          		HPS_SPIM_MISO,
	output		          		HPS_SPIM_MOSI,
	inout 		          		HPS_SPIM_SS,
	input 		          		HPS_UART_RX,
	output		          		HPS_UART_TX,
	input 		          		HPS_USB_CLKOUT,
	inout 		     [7:0]		HPS_USB_DATA,
	input 		          		HPS_USB_DIR,
	input 		          		HPS_USB_NXT,
	output		          		HPS_USB_STP,

	//////////// KEY //////////
	input 		     [1:0]		KEY,

	//////////// LED //////////
	output		     [7:0]		LED,

	//////////// SW //////////
	input 		     [3:0]		SW,

	//////////// GPIO_0, GPIO connect to GPIO Default //////////
	inout 		    [35:0]		GPIO_0,

	//////////// GPIO_1, GPIO connect to GPIO Default //////////
	inout 		    [35:0]		GPIO_1
);
	
// my codes
	wire						RESETN = KEY[0];
	/// generate 3 clocks
	wire						CLOCK80, CLOCK10, CLOCK125, CLOCK25, CLOCK50, CLOCK35, CLOCK45, CLOCK26, CLOCK16 /* synthesis keep */;
	alt_pll_ip_core				alt_pll_ip_core_inst(
									.refclk(FPGA_CLK2_50),
									.rst(0),
									.outclk_0(CLOCK80),
									.outclk_1(CLOCK10),
									.outclk_2(CLOCK125),
									.outclk_3(CLOCK25),
									.outclk_4(CLOCK50),
									.outclk_5(CLOCK35),
									.outclk_6(CLOCK45),
									.outclk_7(CLOCK26),
									.outclk_8(CLOCK16),
									.locked()
								);
	///////////////////////////////////
	// kill key-jitter
	wire			[1:1]		KEY_safe;
	jitter_killer				jitter_killer_KEY1(.sys_clk(CLOCK10),.sys_rst_n(RESETN),.jitter_line(KEY[1]),.jitter_safe(KEY_safe[1]));
	////////////
	// for camera MT9D111
	wire						MT9D111_SCL, MT9D111_SDA;		// I2C  interference
	wire						MT9D111_PCLK, MT9D111_VSYNC, MT9D111_HREF, MT9D111_MCLK;
	wire	[7:0]				MT9D111_D;	// data
	// with GPIO_0
	assign						GPIO_0[2] = MT9D111_SCL;
	assign						MT9D111_PCLK = GPIO_0[6];
	assign						MT9D111_VSYNC = GPIO_0[8];
	assign						MT9D111_HREF = GPIO_0[9];
	assign						GPIO_0[11] = MT9D111_MCLK;
	assign						MT9D111_D[7] = GPIO_0[12];
	assign						MT9D111_D[6] = GPIO_0[13];
	assign						MT9D111_D[5] = GPIO_0[14];
	assign						MT9D111_D[4] = GPIO_0[15];
	assign						MT9D111_D[3] = GPIO_0[16];
	assign						MT9D111_D[2] = GPIO_0[17];
	assign						MT9D111_D[1] = GPIO_0[18];
	assign						MT9D111_D[0] = GPIO_0[19];
	
	assign						GPIO_0[19:12] = 8'HZZ;
	assign						GPIO_0[6] = 1'BZ;
	assign						GPIO_0[8] = 1'BZ;
	assign						GPIO_0[9] = 1'BZ;
	// mt9d111 configuration
	assign						MT9D111_MCLK = CLOCK35;
	mt9d111_config				mt9d111_config_inst(
									.CLOCK10(CLOCK10),
									.RESETN(RESETN),
									.KEY_safe(KEY_safe),
									.configure_sz(612),
									.configuring(LED[0]),
									.mt9d111_SIOC(MT9D111_SCL),
									.mt9d111_SIOD(GPIO_0[3])
								);
								
	// mt9d111 controller (pixel stream)
	wire	[10:0]				MT9D111_HCnt;
	wire	[10:0]				MT9D111_VCnt;
	wire	[15:0]				MT9D111_DATA;
	wire						MT9D111_DATA_EN;
	wire						MT9D111_FRAME_NEW_EN;
	wire						MT9D111_FRAME_HSYNC;
	wire						MT9D111_FRAME_VSYNC;
	mt9d111_controller			mt9d111_controller_inst(
									.MT9D111_PCLK(MT9D111_PCLK),
									.MT9D111_VSYNC(MT9D111_VSYNC),
									.MT9D111_HREF(MT9D111_HREF),
									.MT9D111_D(MT9D111_D),
									.FRAME_Hcnt(MT9D111_HCnt),
									.FRAME_Vcnt(MT9D111_VCnt),
									.FRAME_DATA(MT9D111_DATA),
									.FRAME_DATA_EN(MT9D111_DATA_EN),
									.FRAME_NEW_EN(MT9D111_FRAME_NEW_EN),
									.FRAME_HSYNC(MT9D111_FRAME_HSYNC),
									.FRAME_VSYNC(MT9D111_FRAME_VSYNC)
								);
	// HOG+SVM行人检测
	wire						HOG_SVM_DDR_WRITE_CLK;
	wire	[31:0]				HOG_SVM_DDR_WRITE_ADDR;
	wire	[31:0]				HOG_SVM_DDR_WRITE_DATA;
	wire						HOG_SVM_DDR_WRITE_REQ;
	wire						HOG_SVM_DDR_WRITE_READY;
	/*
	*/
	hog_svm_pd_rtl				hog_svm_pd_rtl_inst(
									.sys_rst_n(RESETN),
									.RGB565_PCLK(MT9D111_PCLK),
									.RGB565_HSYNC(MT9D111_FRAME_HSYNC),
									.RGB565_VSYNC(MT9D111_FRAME_VSYNC),
									.RGB565_D(MT9D111_DATA),
									.RGB565_DE(MT9D111_DATA_EN),
									//
									.DDR_WRITE_CLK(HOG_SVM_DDR_WRITE_CLK),
									.DDR_WRITE_ADDR(HOG_SVM_DDR_WRITE_ADDR),
									.DDR_WRITE_DATA(HOG_SVM_DDR_WRITE_DATA),
									.DDR_WRITE_REQ(HOG_SVM_DDR_WRITE_REQ),
									.DDR_WRITE_READY(HOG_SVM_DDR_WRITE_READY)
								);
	// 光流计算
	// OpticalFlowLK
	wire	[5:0]				MT9D111_FRAME_PREV;
	wire	[5:0]				MT9D111_FRAME_CURR /* synthesis keep */;
	wire	[5:0]				OPTICAL_FRAME;
	wire						OPTICAL_RDCLK = CLOCK80;
	wire						OPTICAL_DDR_WRITE_CLK;
	wire	[31:0]				OPTICAL_DDR_WRITE_ADDR;
	wire	[31:0]				OPTICAL_DDR_WRITE_DATA;
	wire						OPTICAL_DDR_WRITE_REQ;
	wire						OPTICAL_DDR_WRITE_READY;
	wire						OPTICAL_DDR_READ_CLK;
	wire	[31:0]				OPTICAL_DDR_READ_ADDR;
	wire						OPTICAL_DDR_READ_REQ;
	wire						OPTICAL_DDR_READ_READY;
	wire	[31:0]				OPTICAL_DDR_READ_DATA;
	wire						OPTICAL_DDR_READ_DATA_VALID;
	/*
	*/
	OpticalFlowLK				OpticalFlowLK_inst(
									.sys_rst_n(RESETN),
									.RGB565_PCLK(MT9D111_PCLK),
									.RGB565_HSYNC(MT9D111_FRAME_HSYNC),
									.RGB565_VSYNC(MT9D111_FRAME_VSYNC),
									.RGB565_D(MT9D111_DATA),
									.RGB565_DE(MT9D111_DATA_EN),
									.PREV_FRAME(MT9D111_FRAME_PREV),
									.CURR_FRAME(MT9D111_FRAME_CURR),
									.OPTICAL_FRAME(OPTICAL_FRAME),
									.OPTICAL_RDCLK(OPTICAL_RDCLK),
									// DDR
									.DDR_WRITE_CLK(OPTICAL_DDR_WRITE_CLK),
									.DDR_WRITE_ADDR(OPTICAL_DDR_WRITE_ADDR),
									.DDR_WRITE_DATA(OPTICAL_DDR_WRITE_DATA),
									.DDR_WRITE_REQ(OPTICAL_DDR_WRITE_REQ),
									.DDR_WRITE_READY(OPTICAL_DDR_WRITE_READY),
									.DDR_READ_CLK(OPTICAL_DDR_READ_CLK),
									.DDR_READ_ADDR(OPTICAL_DDR_READ_ADDR),
									.DDR_READ_REQ(OPTICAL_DDR_READ_REQ),
									.DDR_READ_READY(OPTICAL_DDR_READ_READY),
									.DDR_READ_DATA(OPTICAL_DDR_READ_DATA),
									.DDR_READ_DATA_VALID(OPTICAL_DDR_READ_DATA_VALID)
								);
	// adv7513
	wire						ADV7513_SCL;
	wire						ADV7513_INT;
	wire	[10:0]				ADV7513_HCnt /* synthesis noprune */;
	wire	[10:0]				ADV7513_VCnt;
	wire	[15:0]				ADV7513_DATA;
	wire						ADV7513_DATA_REQ;
	wire						ADV7513_FRAME_NEW_EN;
	wire						ADV7513_HSYNC;
	wire						ADV7513_VSYNC;
	wire	[4:0]				ADV7513_R;
	wire	[5:0]				ADV7513_G;
	wire	[4:0]				ADV7513_B;	
	wire						ADV7513_DE;
	wire						ADV7513_PCLK;
	wire						ADV7513_PCLK_pll;
	// to pin
	assign						HDMI_I2C_SCL = ADV7513_SCL;
	assign						ADV7513_INT = HDMI_TX_INT;
	assign						HDMI_TX_CLK = ADV7513_PCLK;
	assign						HDMI_TX_D = {ADV7513_R, ADV7513_R[2], ADV7513_R[3], ADV7513_R[4], ADV7513_G, ADV7513_G[4], ADV7513_G[5], ADV7513_B, ADV7513_B[2], ADV7513_B[3], ADV7513_B[4]};
	assign						HDMI_TX_DE = ADV7513_DE;
	assign						HDMI_TX_HS = ADV7513_HSYNC;
	assign						HDMI_TX_VS = ADV7513_VSYNC;
	// adv7513 configuration
	assign						ADV7513_PCLK = CLOCK25;	// 26 MHz --> HDMI ( 1024x768 @ 24fps )
	assign						ADV7513_PCLK_pll = CLOCK80;	// 65MHz读取DDR
	adv7513_config				adv7513_config_inst(
									.CLOCK10(CLOCK10),
									.RESETN(RESETN),
									.KEY_safe(KEY_safe),
									.configure_sz(22),
									.configuring(),
									.adv7513_SIOC(ADV7513_SCL),
									.adv7513_SIOD(HDMI_I2C_SDA)
								);
	
	// 要显示的字幕
	wire	[2:0]				ACTION_CLASS;
	wire	[0:0]				ACTION_q;
	wire	[15:0]				ACTION_WORD = (ACTION_q==1)? 16'HF800 : 16'HFFFF;
	wire	[31:0]				ACTION_ADDR = 16384*ACTION_CLASS + `WORD_H_WIDTH*(ADV7513_VCnt-`WORD_V_BIAS) + (ADV7513_HCnt-`WORD_H_BIAS);
	wire	[0:0]				TITLE_q;
	wire	[15:0]				TITLE_WORD = (TITLE_q==1)? 16'HF800 : 16'HFFFF;
	wire	[31:0]				TITLE_ADDR = (`TITLE_H_WIDTH)*(ADV7513_VCnt-`TITLE_V_BIAS) + (ADV7513_HCnt-`TITLE_H_BIAS);
	// adv7513 hdmi output
	adv7513_controller			adv7513_controller_inst(
									.ADV7513_PCLK(ADV7513_PCLK),
									.RESETN(RESETN),
									.ADV7513_R(ADV7513_R),
									.ADV7513_G(ADV7513_G),
									.ADV7513_B(ADV7513_B),
									.ADV7513_HSYNC(ADV7513_HSYNC),
									.ADV7513_VSYNC(ADV7513_VSYNC),
									.ADV7513_FRAME_NEW_EN(ADV7513_FRAME_NEW_EN),
									.ADV7513_BLANK_N(),
									.ADV7513_VCnt(ADV7513_VCnt),
									.ADV7513_HCnt(ADV7513_HCnt),
									.ADV7513_DATA(ADV7513_DATA),
									.ADV7513_DATA_REQ(ADV7513_DATA_REQ),
									.ADV7513_DE(ADV7513_DE),
									.ACTION_WORD(ACTION_WORD),
									.ACTION_TITLE(TITLE_WORD),
									.SW(SW)
								);
	// 字幕的rOM 
	word_display_rom			word_display_rom_inst(
									.clock(ADV7513_PCLK),
									.address(ACTION_ADDR),
									.q(ACTION_q)
								);
	// 字幕的rOM 
	word_title_rom				word_title_rom_inst(
									.clock(ADV7513_PCLK),
									.address(TITLE_ADDR),
									.q(TITLE_q)
								);
								
	///////////////////////////// CNN 指令集架构
	/*
	*/
	reg		[127:0]				cnn_inst /* synthesis noprune */;
	reg							cnn_inst_en /* synthesis noprune */;
	wire						cnn_inst_ready;
	// 计量NPU指令计算周期数
	wire	[31:0]				cnn_inst_time;
	wire						CNN_DDR_WRITE_CLK;
	wire	[31:0]				CNN_DDR_WRITE_ADDR;
	wire	[31:0]				CNN_DDR_WRITE_DATA;
	wire						CNN_DDR_WRITE_REQ;
	wire						CNN_DDR_WRITE_READY;
	wire						CNN_DDR_READ_CLK;
	wire	[31:0]				CNN_DDR_READ_ADDR;
	wire						CNN_DDR_READ_REQ;
	wire						CNN_DDR_READ_READY;
	wire	[31:0]				CNN_DDR_READ_DATA;
	wire						CNN_DDR_READ_DATA_VALID;
	wire						cnn_inst_clk = CLOCK45;
    wire    [31:0]              cnn_inst_addr;
    wire    [127:0]             cnn_inst_q;
    wire                        cnn_inst_start = (cnn_inst_en && cnn_inst==128'D2);
	
	
	cnn_inst_executor			cnn_inst_executor_inst(
									.clk(cnn_inst_clk),
									.rst_n(RESETN & HPS2FPGA_RESETN),
									.cnn_inst_addr(cnn_inst_addr),
									.cnn_inst_q(cnn_inst_q),
									.cnn_inst_start(cnn_inst_start),
									.cnn_inst_ready(cnn_inst_ready),
									.cnn_inst_time(cnn_inst_time),
									// DDR
									.DDR_WRITE_CLK(CNN_DDR_WRITE_CLK),
									.DDR_WRITE_ADDR(CNN_DDR_WRITE_ADDR),
									.DDR_WRITE_DATA(CNN_DDR_WRITE_DATA),
									.DDR_WRITE_REQ(CNN_DDR_WRITE_REQ),
									.DDR_WRITE_READY(CNN_DDR_WRITE_READY),
									.DDR_READ_CLK(CNN_DDR_READ_CLK),
									.DDR_READ_ADDR(CNN_DDR_READ_ADDR),
									.DDR_READ_REQ(CNN_DDR_READ_REQ),
									.DDR_READ_READY(CNN_DDR_READ_READY),
									.DDR_READ_DATA(CNN_DDR_READ_DATA),
									.DDR_READ_DATA_VALID(CNN_DDR_READ_DATA_VALID)
								);
               
    // 存储CNN指令的地址
    reg     [31:0]      cnn_inst_wraddr;
    always @(posedge cnn_inst_clk)
        if(cnn_inst_en && cnn_inst==128'D1)
            cnn_inst_wraddr <= 0;
        else if(cnn_inst_en && cnn_inst!=128'D1 && cnn_inst!=128'D2)
            cnn_inst_wraddr <= cnn_inst_wraddr  +1;
    // 然后要将CNN指令存储到RAM里面去
    cnn_inst_ram            cnn_inst_ram_inst(
                                .data(cnn_inst),
                                .wren(cnn_inst_en && cnn_inst!=128'D1 && cnn_inst!=128'D2),
                                .wraddress(cnn_inst_wraddr),
                                .wrclock(cnn_inst_clk),
                                .rdclock(cnn_inst_clk),
                                .rdaddress(cnn_inst_addr),
                                .q(cnn_inst_q)
                            );
    cnn_inst_ram_shadow     cnn_inst_ram_shadow_inst(
                                .data(cnn_inst),
                                .wren(cnn_inst_en && cnn_inst!=128'D1 && cnn_inst!=128'D2),
                                .address(cnn_inst_wraddr),
                                .clock(cnn_inst_clk)
                            );
    
	// 生成cnn_inst/cnn_inst_en
	// 要用状态机来生成
	wire	[31:0]	cnn_inst_part;
	wire			cnn_inst_part_en;
	reg		[3:0]	cnn_inst_state;
	reg		[31:0]	cnn_inst_delay;	// 延时计数单元，如果超时了，就说明指令传输完成
	always @(posedge cnn_inst_clk)
		if(!RESETN)
		begin
			cnn_inst_state <= 0;
			cnn_inst <= 0;
			cnn_inst_en <= 0;
			cnn_inst_delay <= 0;
		end
		else
		begin
			case(cnn_inst_state)
				0: begin
					if(cnn_inst_part_en)
					begin
						cnn_inst <= {cnn_inst[95:0], cnn_inst_part};
						cnn_inst_en <= 0;
						cnn_inst_state <= 1;
						cnn_inst_delay <= 0;
					end
				end
				
				// 等待超时了，就说明指令传输完成
				1: begin
					if(cnn_inst_part_en)
					begin
						cnn_inst <= {cnn_inst[95:0], cnn_inst_part};
						cnn_inst_en <= 0;
						cnn_inst_delay <= 0;
					end
					else if(cnn_inst_delay>=500)
					begin
						cnn_inst_en <= 1;
						cnn_inst_state <= 2;
						cnn_inst_delay <= 0;
					end
					else 
						cnn_inst_delay <= cnn_inst_delay + 1;	// 超时等待计数器++
				end
				
				// 
				2: begin
					cnn_inst_en <= 0;
					cnn_inst_state <= 0;
				end
				
				default: begin
					cnn_inst_state <= 0;
					cnn_inst <= 0;
					cnn_inst_en <= 0;
					cnn_inst_delay <= 0;
				end
				
			endcase
		end
	
	//////////////////////////////////////////
	// HPS正在写入的内存块
	wire	[7:0]				PD_BBOX_FRAME;
	// save into DDR
	wire						VIDEO_DDR_WRITE_CLK;
	wire	[31:0]				VIDEO_DDR_WRITE_ADDR;
	wire	[31:0]				VIDEO_DDR_WRITE_DATA;
	wire						VIDEO_DDR_WRITE_REQ;
	wire						VIDEO_DDR_WRITE_READY;
	wire						VIDEO_DDR_READ_CLK;
	wire	[31:0]				VIDEO_DDR_READ_ADDR;
	wire						VIDEO_DDR_READ_REQ;
	wire						VIDEO_DDR_READ_READY;
	wire	[31:0]				VIDEO_DDR_READ_DATA;
	wire						VIDEO_DDR_READ_DATA_VALID;
	wire						HPS2FPGA_RESETN /* synthesis keep */;	// 从HPS给出的，让FPGA不要访问DDR存储器，或者说，不让FPGA有任何动作
	video_process				video_process_inst(
									.sys_clk(CLOCK50),
									.sys_rst_n(RESETN & HPS2FPGA_RESETN),
									.SW(SW),
									// MT9D111
									.MT9D111_CLK(MT9D111_PCLK),
									.MT9D111_FrameData(MT9D111_DATA),
									.MT9D111_FrameDataEn(MT9D111_DATA_EN),
									.MT9D111_FrameHCnt(MT9D111_HCnt),
									.MT9D111_FrameVCnt(MT9D111_VCnt),
									.MT9D111_FrameNewEn(MT9D111_FRAME_NEW_EN),
									// ADV7513
									.ADV7513_CLK(ADV7513_PCLK),
									.ADV7513_CLK_pll(ADV7513_PCLK_pll),
									.ADV7513_FrameData(ADV7513_DATA),
									.ADV7513_FrameDataReq(ADV7513_DATA_REQ),
									.ADV7513_FrameHCnt(ADV7513_HCnt),
									.ADV7513_FrameVCnt(ADV7513_VCnt),
									.ADV7513_FrameNewEn(ADV7513_FRAME_NEW_EN),
									// 还有光流法正在写入的区间快
									.OPTICAL_FRAME(OPTICAL_FRAME),
									.MT9D111_FRAME_CURR(MT9D111_FRAME_CURR),
									.MT9D111_FRAME_PREV(MT9D111_FRAME_PREV),
									// 行人检测加框结果正在写入的内存块
									.PD_BBOX_FRAME(PD_BBOX_FRAME),
									// DDR
									.DDR_WRITE_CLK(VIDEO_DDR_WRITE_CLK),
									.DDR_WRITE_ADDR(VIDEO_DDR_WRITE_ADDR),
									.DDR_WRITE_DATA(VIDEO_DDR_WRITE_DATA),
									.DDR_WRITE_REQ(VIDEO_DDR_WRITE_REQ),
									.DDR_WRITE_READY(VIDEO_DDR_WRITE_READY),
									.DDR_READ_CLK(VIDEO_DDR_READ_CLK),
									.DDR_READ_ADDR(VIDEO_DDR_READ_ADDR),
									.DDR_READ_REQ(VIDEO_DDR_READ_REQ),
									.DDR_READ_READY(VIDEO_DDR_READ_READY),
									.DDR_READ_DATA(VIDEO_DDR_READ_DATA),
									.DDR_READ_DATA_VALID(VIDEO_DDR_READ_DATA_VALID)
								);

	wire        avalon_clk_clk = CLOCK125;                  //     avalon_clk.clk
	wire        avalon_clk_lw_clk = CLOCK50;                  //     avalon_lw_clk.clk
	wire        avalon_reset_reset_n = RESETN;          // avalon_reset_n.export
	wire		avalon_reset_lw_reset_n = RESETN;

	wire        avalon_f2s0_waitrequest;          //     avalon_f2s0.waitrequest
	wire [31:0] avalon_f2s0_readdata;             //               .readdata
	wire        avalon_f2s0_readdatavalid;        //               .readdatavalid
	wire [7:0]  avalon_f2s0_burstcount;           //               .burstcount
	wire [31:0] avalon_f2s0_writedata;            //               .writedata
	wire [31:0] avalon_f2s0_address;              //               .address
	wire        avalon_f2s0_write;                //               .write
	wire        avalon_f2s0_read;                 //               .read
	wire [3:0]  avalon_f2s0_byteenable;           //               .byteenable

	wire        avalon_f2s1_waitrequest;          //     avalon_f2s1.waitrequest
	wire [31:0] avalon_f2s1_readdata;             //               .readdata
	wire        avalon_f2s1_readdatavalid;        //               .readdatavalid
	wire [7:0]  avalon_f2s1_burstcount;           //               .burstcount
	wire [31:0] avalon_f2s1_writedata;            //               .writedata
	wire [31:0] avalon_f2s1_address;              //               .address
	wire        avalon_f2s1_write;                //               .write
	wire        avalon_f2s1_read;                 //               .read
	wire [3:0]  avalon_f2s1_byteenable;           //               .byteenable
	
	wire        avalon_f2s2_waitrequest;          //     avalon_f2s2.waitrequest
	wire [31:0] avalon_f2s2_readdata;             //               .readdata
	wire        avalon_f2s2_readdatavalid;        //               .readdatavalid
	wire [7:0]  avalon_f2s2_burstcount;           //               .burstcount
	wire [31:0] avalon_f2s2_writedata;            //               .writedata
	wire [31:0] avalon_f2s2_address;              //               .address
	wire        avalon_f2s2_write;                //               .write
	wire        avalon_f2s2_read;                 //               .read
	wire [3:0]  avalon_f2s2_byteenable;           //               .byteenable
	
	
	wire        avalon_f2h_waitrequest;          //     avalon_f2h.waitrequest
	wire [31:0] avalon_f2h_readdata;             //               .readdata
	wire        avalon_f2h_readdatavalid;        //               .readdatavalid
	wire        avalon_f2h_beginbursttransfer;   //               .beginbursttransfer
	wire        avalon_f2h_begintransfer;        //               .begintransfer
	wire [7:0]  avalon_f2h_burstcount;           //               .burstcount
	wire [31:0] avalon_f2h_writedata;            //               .writedata
	wire [31:0] avalon_f2h_address;              //               .address
	wire        avalon_f2h_write;                //               .write
	wire        avalon_f2h_read;                 //               .read
	wire [3:0]  avalon_f2h_byteenable;           //               .byteenable
	
	
	wire [21:0] avalon_h2f_address;                   //                  avalon_h2f.address
	wire        avalon_h2f_write;                     //                            .write
	wire        avalon_h2f_read;                      //                            .read
	wire [31:0] avalon_h2f_readdata;                  //                            .readdata
	wire [31:0] avalon_h2f_writedata;                 //                            .writedata
	wire        avalon_h2f_begintransfer;             //                            .begintransfer
	wire        avalon_h2f_beginbursttransfer;        //                            .beginbursttransfer
	wire [3:0]  avalon_h2f_burstcount;                //                            .burstcount
	wire [3:0]  avalon_h2f_byteenable;                //                            .byteenable
	wire        avalon_h2f_readdatavalid;             //                            .readdatavalid
	wire        avalon_h2f_waitrequest;               //                            .waitrequest
	
	wire [15:0] avalon_h2f_lw_address;                //               avalon_h2f_lw.address
	wire        avalon_h2f_lw_write;                  //                            .write
	wire        avalon_h2f_lw_read;                   //                            .read
	wire [31:0] avalon_h2f_lw_readdata;               //                            .readdata
	wire [31:0] avalon_h2f_lw_writedata;              //                            .writedata
	wire        avalon_h2f_lw_begintransfer;          //                            .begintransfer
	wire        avalon_h2f_lw_beginbursttransfer;     //                            .beginbursttransfer
	wire [3:0]  avalon_h2f_lw_burstcount;             //                            .burstcount
	wire [3:0]  avalon_h2f_lw_byteenable;             //                            .byteenable
	wire        avalon_h2f_lw_readdatavalid;          //                            .readdatavalid
	wire        avalon_h2f_lw_waitrequest;            //                            .waitrequest
	
	// h2f/h2f_lw两个接口始终有效
	assign		avalon_h2f_waitrequest = 0;
	assign		avalon_h2f_lw_waitrequest = 0;
	
	// 将H2F传输的NPU指令通过DCFIFO交给NPU指令生成FSM
	wire			[31:0]	cnn_inst_part_fifo_data = avalon_h2f_writedata;
	wire					cnn_inst_part_fifo_wrreq = avalon_h2f_write;
	wire			[31:0]	cnn_inst_part_fifo_q;
	wire					cnn_inst_part_fifo_rdempty;
	wire			[5:0]	cnn_inst_part_fifo_rdusedw;
	// 使用状态机从FIFO里面读取出数据
	assign					cnn_inst_part = cnn_inst_part_fifo_q;
	assign					cnn_inst_part_en = !cnn_inst_part_fifo_rdempty;
	// FIFO例化
	alt_fifo_32b_64w		cnn_inst_part_fifo(
								.aclr(!RESETN),
								.data(cnn_inst_part_fifo_data),
								.wrclk(avalon_clk_lw_clk),
								.wrreq(cnn_inst_part_fifo_wrreq),
								.rdusedw(cnn_inst_part_fifo_rdusedw),
								.q(cnn_inst_part_fifo_q),
								.rdclk(cnn_inst_clk),
								.rdreq(!cnn_inst_part_fifo_rdempty),
								.rdempty(cnn_inst_part_fifo_rdempty)
							);
	
	
	/*		
	*/			
	/////////////////////////////
	mux_ddr_access		mux_ddr_access_f2s0_inst(
							.afi_phy_clk(avalon_clk_clk),
							.afi_phy_rst_n(avalon_reset_reset_n & HPS2FPGA_RESETN),
							//
							.local_address(avalon_f2s0_address),
							.local_write_req(avalon_f2s0_write),
							.local_read_req(avalon_f2s0_read),
							.local_burstbegin(),
							.local_wdata(avalon_f2s0_writedata),
							.local_be(avalon_f2s0_byteenable),
							.local_size(avalon_f2s0_burstcount),
							.local_ready(!avalon_f2s0_waitrequest),
							.local_rdata(avalon_f2s0_readdata),
							.local_rdata_valid(avalon_f2s0_readdatavalid),
							//.local_refresh_ack,
							.local_init_done(RESETN & avalon_reset_reset_n),
							///////////////
							// HOG+SVM行人检测结果回写
							.wport_clock_2(HOG_SVM_DDR_WRITE_CLK),
							.wport_addr_2(HOG_SVM_DDR_WRITE_ADDR),	// 上方 448MB~480 MB属于HOG+SVM结果的缓存 
							.wport_data_2(HOG_SVM_DDR_WRITE_DATA),
							.wport_req_2(HOG_SVM_DDR_WRITE_REQ),
							.wport_ready_2(HOG_SVM_DDR_WRITE_READY),
							// 光流法的写入接口
							.wport_clock_0(OPTICAL_DDR_WRITE_CLK),
							.wport_addr_0(OPTICAL_DDR_WRITE_ADDR),	// 上方 480MB~512 MB属于光流法运算结果的缓存 -- 8MB/frame
							.wport_data_0(OPTICAL_DDR_WRITE_DATA),
							.wport_req_0(OPTICAL_DDR_WRITE_REQ),
							.wport_ready_0(OPTICAL_DDR_WRITE_READY),		
							// 光流法的读取接口
							.rport_clock_1(OPTICAL_DDR_READ_CLK),
							.rport_addr_1(OPTICAL_DDR_READ_ADDR),	// 上方 512MB~544 MB属于相机拍摄的缓存 -- 8MB/frame
							.rport_data_1(OPTICAL_DDR_READ_DATA),
							.rport_data_valid_1(OPTICAL_DDR_READ_DATA_VALID),
							.rport_req_1(OPTICAL_DDR_READ_REQ),
							.rport_ready_1(OPTICAL_DDR_READ_READY)
						);
	/////////////////////////////
	mux_ddr_access		mux_ddr_access_f2s1_inst(
							.afi_phy_clk(avalon_clk_clk),
							.afi_phy_rst_n(avalon_reset_reset_n & HPS2FPGA_RESETN),
							//
							.local_address(avalon_f2s1_address),
							.local_write_req(avalon_f2s1_write),
							.local_read_req(avalon_f2s1_read),
							.local_burstbegin(),
							.local_wdata(avalon_f2s1_writedata),
							.local_be(avalon_f2s1_byteenable),
							.local_size(avalon_f2s1_burstcount),
							.local_ready(!avalon_f2s1_waitrequest),
							.local_rdata(avalon_f2s1_readdata),
							.local_rdata_valid(avalon_f2s1_readdatavalid),
							//.local_refresh_ack,
							.local_init_done(RESETN & avalon_reset_reset_n),
							///////////////
							// MT9D111 写入
							.wport_clock_0(VIDEO_DDR_WRITE_CLK),
							.wport_addr_0(VIDEO_DDR_WRITE_ADDR),	// 上方 512MB~1024 MB属于相机拍摄的缓存 -- 8MB/frame
							.wport_data_0(VIDEO_DDR_WRITE_DATA),
							.wport_req_0(VIDEO_DDR_WRITE_REQ),
							.wport_ready_0(VIDEO_DDR_WRITE_READY),
							// ADV7513读出
							.rport_clock_1(VIDEO_DDR_READ_CLK),
							.rport_addr_1(VIDEO_DDR_READ_ADDR),	// 上方 512MB~1024 MB属于相机拍摄的缓存 -- 8MB/frame
							.rport_data_1(VIDEO_DDR_READ_DATA),
							.rport_data_valid_1(VIDEO_DDR_READ_DATA_VALID),
							.rport_req_1(VIDEO_DDR_READ_REQ),
							.rport_ready_1(VIDEO_DDR_READ_READY)
						);
	// 然后是f2h接口
	mux_ddr_access		mux_ddr_access_f2h_inst(
							.afi_phy_clk(avalon_clk_clk),
							.afi_phy_rst_n(avalon_reset_reset_n & HPS2FPGA_RESETN),
							//
							.local_address(avalon_f2h_address),
							.local_write_req(avalon_f2h_write),
							.local_read_req(avalon_f2h_read),
							.local_burstbegin(),
							.local_wdata(avalon_f2h_writedata),
							.local_be(avalon_f2h_byteenable),
							.local_size(avalon_f2h_burstcount),
							.local_ready(!avalon_f2h_waitrequest),
							.local_rdata(avalon_f2h_readdata),
							.local_rdata_valid(avalon_f2h_readdatavalid),
							//.local_refresh_ack,
							.local_init_done(RESETN & avalon_reset_reset_n),
							///////////////
							// CNN读写接口
							.wport_clock_4(CNN_DDR_WRITE_CLK),
							.wport_addr_4(CNN_DDR_WRITE_ADDR),
							.wport_data_4(CNN_DDR_WRITE_DATA),
							.wport_req_4(CNN_DDR_WRITE_REQ),
							.wport_ready_4(CNN_DDR_WRITE_READY),
							// CNN读写接口
							.rport_clock_3(CNN_DDR_READ_CLK),
							.rport_addr_3(CNN_DDR_READ_ADDR),
							.rport_data_3(CNN_DDR_READ_DATA),
							.rport_data_valid_3(CNN_DDR_READ_DATA_VALID),
							.rport_req_3(CNN_DDR_READ_REQ),
							.rport_ready_3(CNN_DDR_READ_READY)
						);	
//////////////////////////////////////////////////////////////////////////////////
//=======================================================
//  REG/WIRE declarations
//=======================================================
  wire  hps_fpga_reset_n;
  wire [1:0] fpga_debounced_buttons;
  wire [6:0]  fpga_led_internal;
  wire [2:0]  hps_reset_req;
  wire        hps_cold_reset;
  wire        hps_warm_reset;
  wire        hps_debug_reset;
  wire [27:0] stm_hw_events;
  wire 		  fpga_clk_50;
// connection of internal logics
  assign LED[7:1] = fpga_led_internal;
  assign ACTION_CLASS = fpga_led_internal;
  assign fpga_clk_50=FPGA_CLK1_50;
  assign stm_hw_events    = {{15{1'b0}}, SW, fpga_led_internal, fpga_debounced_buttons};

  assign HPS2FPGA_RESETN = fpga_led_internal[6];
//=======================================================
//  Structural coding
//=======================================================
`ifndef NOT_USE_HPS		// 如果使用了HPS

 soc_system u0 (
		//Clock&Reset
//	  .clk_clk                               (FPGA_CLK1_50 ),                               //                            clk.clk
//	  .reset_reset_n                         (hps_fpga_reset_n ),                         //                          reset.reset_n
	  //HPS ddr3
	  .memory_mem_a                          ( HPS_DDR3_ADDR),                       //                memory.mem_a
	  .memory_mem_ba                         ( HPS_DDR3_BA),                         //                .mem_ba
	  .memory_mem_ck                         ( HPS_DDR3_CK_P),                       //                .mem_ck
	  .memory_mem_ck_n                       ( HPS_DDR3_CK_N),                       //                .mem_ck_n
	  .memory_mem_cke                        ( HPS_DDR3_CKE),                        //                .mem_cke
	  .memory_mem_cs_n                       ( HPS_DDR3_CS_N),                       //                .mem_cs_n
	  .memory_mem_ras_n                      ( HPS_DDR3_RAS_N),                      //                .mem_ras_n
	  .memory_mem_cas_n                      ( HPS_DDR3_CAS_N),                      //                .mem_cas_n
	  .memory_mem_we_n                       ( HPS_DDR3_WE_N),                       //                .mem_we_n
	  .memory_mem_reset_n                    ( HPS_DDR3_RESET_N),                    //                .mem_reset_n
	  .memory_mem_dq                         ( HPS_DDR3_DQ),                         //                .mem_dq
	  .memory_mem_dqs                        ( HPS_DDR3_DQS_P),                      //                .mem_dqs
	  .memory_mem_dqs_n                      ( HPS_DDR3_DQS_N),                      //                .mem_dqs_n
	  .memory_mem_odt                        ( HPS_DDR3_ODT),                        //                .mem_odt
	  .memory_mem_dm                         ( HPS_DDR3_DM),                         //                .mem_dm
	  .memory_oct_rzqin                      ( HPS_DDR3_RZQ),                        //                .oct_rzqin                                  
	  //HPS ethernet		
	  .hps_io_hps_io_emac1_inst_TX_CLK ( HPS_ENET_GTX_CLK),       //                             hps_io.hps_io_emac1_inst_TX_CLK
	  .hps_io_hps_io_emac1_inst_TXD0   ( HPS_ENET_TX_DATA[0] ),   //                             .hps_io_emac1_inst_TXD0
	  .hps_io_hps_io_emac1_inst_TXD1   ( HPS_ENET_TX_DATA[1] ),   //                             .hps_io_emac1_inst_TXD1
	  .hps_io_hps_io_emac1_inst_TXD2   ( HPS_ENET_TX_DATA[2] ),   //                             .hps_io_emac1_inst_TXD2
	  .hps_io_hps_io_emac1_inst_TXD3   ( HPS_ENET_TX_DATA[3] ),   //                             .hps_io_emac1_inst_TXD3
	  .hps_io_hps_io_emac1_inst_RXD0   ( HPS_ENET_RX_DATA[0] ),   //                             .hps_io_emac1_inst_RXD0
	  .hps_io_hps_io_emac1_inst_MDIO   ( HPS_ENET_MDIO ),         //                             .hps_io_emac1_inst_MDIO
	  .hps_io_hps_io_emac1_inst_MDC    ( HPS_ENET_MDC  ),         //                             .hps_io_emac1_inst_MDC
	  .hps_io_hps_io_emac1_inst_RX_CTL ( HPS_ENET_RX_DV),         //                             .hps_io_emac1_inst_RX_CTL
	  .hps_io_hps_io_emac1_inst_TX_CTL ( HPS_ENET_TX_EN),         //                             .hps_io_emac1_inst_TX_CTL
	  .hps_io_hps_io_emac1_inst_RX_CLK ( HPS_ENET_RX_CLK),        //                             .hps_io_emac1_inst_RX_CLK
	  .hps_io_hps_io_emac1_inst_RXD1   ( HPS_ENET_RX_DATA[1] ),   //                             .hps_io_emac1_inst_RXD1
	  .hps_io_hps_io_emac1_inst_RXD2   ( HPS_ENET_RX_DATA[2] ),   //                             .hps_io_emac1_inst_RXD2
	  .hps_io_hps_io_emac1_inst_RXD3   ( HPS_ENET_RX_DATA[3] ),   //                             .hps_io_emac1_inst_RXD3		  
	  //HPS SD card 
	  .hps_io_hps_io_sdio_inst_CMD     ( HPS_SD_CMD    ),           //                               .hps_io_sdio_inst_CMD
	  .hps_io_hps_io_sdio_inst_D0      ( HPS_SD_DATA[0]     ),      //                               .hps_io_sdio_inst_D0
	  .hps_io_hps_io_sdio_inst_D1      ( HPS_SD_DATA[1]     ),      //                               .hps_io_sdio_inst_D1
	  .hps_io_hps_io_sdio_inst_CLK     ( HPS_SD_CLK   ),            //                               .hps_io_sdio_inst_CLK
	  .hps_io_hps_io_sdio_inst_D2      ( HPS_SD_DATA[2]     ),      //                               .hps_io_sdio_inst_D2
	  .hps_io_hps_io_sdio_inst_D3      ( HPS_SD_DATA[3]     ),      //                               .hps_io_sdio_inst_D3
	  //HPS USB 		  
	  .hps_io_hps_io_usb1_inst_D0      ( HPS_USB_DATA[0]    ),      //                               .hps_io_usb1_inst_D0
	  .hps_io_hps_io_usb1_inst_D1      ( HPS_USB_DATA[1]    ),      //                               .hps_io_usb1_inst_D1
	  .hps_io_hps_io_usb1_inst_D2      ( HPS_USB_DATA[2]    ),      //                               .hps_io_usb1_inst_D2
	  .hps_io_hps_io_usb1_inst_D3      ( HPS_USB_DATA[3]    ),      //                               .hps_io_usb1_inst_D3
	  .hps_io_hps_io_usb1_inst_D4      ( HPS_USB_DATA[4]    ),      //                               .hps_io_usb1_inst_D4
	  .hps_io_hps_io_usb1_inst_D5      ( HPS_USB_DATA[5]    ),      //                               .hps_io_usb1_inst_D5
	  .hps_io_hps_io_usb1_inst_D6      ( HPS_USB_DATA[6]    ),      //                               .hps_io_usb1_inst_D6
	  .hps_io_hps_io_usb1_inst_D7      ( HPS_USB_DATA[7]    ),      //                               .hps_io_usb1_inst_D7
	  .hps_io_hps_io_usb1_inst_CLK     ( HPS_USB_CLKOUT    ),       //                               .hps_io_usb1_inst_CLK
	  .hps_io_hps_io_usb1_inst_STP     ( HPS_USB_STP    ),          //                               .hps_io_usb1_inst_STP
	  .hps_io_hps_io_usb1_inst_DIR     ( HPS_USB_DIR    ),          //                               .hps_io_usb1_inst_DIR
	  .hps_io_hps_io_usb1_inst_NXT     ( HPS_USB_NXT    ),          //                               .hps_io_usb1_inst_NXT
		//HPS SPI 		  
	  .hps_io_hps_io_spim1_inst_CLK    ( HPS_SPIM_CLK  ),           //                               .hps_io_spim1_inst_CLK
	  .hps_io_hps_io_spim1_inst_MOSI   ( HPS_SPIM_MOSI ),           //                               .hps_io_spim1_inst_MOSI
	  .hps_io_hps_io_spim1_inst_MISO   ( HPS_SPIM_MISO ),           //                               .hps_io_spim1_inst_MISO
	  .hps_io_hps_io_spim1_inst_SS0    ( HPS_SPIM_SS   ),             //                               .hps_io_spim1_inst_SS0
		//HPS UART		
	  .hps_io_hps_io_uart0_inst_RX     ( HPS_UART_RX   ),          //                               .hps_io_uart0_inst_RX
	  .hps_io_hps_io_uart0_inst_TX     ( HPS_UART_TX   ),          //                               .hps_io_uart0_inst_TX
		//HPS I2C1
	  .hps_io_hps_io_i2c0_inst_SDA     ( HPS_I2C0_SDAT  ),        //                               .hps_io_i2c0_inst_SDA
	  .hps_io_hps_io_i2c0_inst_SCL     ( HPS_I2C0_SCLK  ),        //                               .hps_io_i2c0_inst_SCL
		//HPS I2C2
	  .hps_io_hps_io_i2c1_inst_SDA     ( HPS_I2C1_SDAT  ),        //                               .hps_io_i2c1_inst_SDA
	  .hps_io_hps_io_i2c1_inst_SCL     ( HPS_I2C1_SCLK  ),        //                               .hps_io_i2c1_inst_SCL
		//GPIO 
	  .hps_io_hps_io_gpio_inst_GPIO09  ( HPS_CONV_USB_N ),  //                               .hps_io_gpio_inst_GPIO09
	  .hps_io_hps_io_gpio_inst_GPIO35  ( HPS_ENET_INT_N ),  //                               .hps_io_gpio_inst_GPIO35
	  .hps_io_hps_io_gpio_inst_GPIO40  ( HPS_LTC_GPIO   ),  //                               .hps_io_gpio_inst_GPIO40
	  .hps_io_hps_io_gpio_inst_GPIO53  ( HPS_LED   ),  //                               .hps_io_gpio_inst_GPIO53
	  .hps_io_hps_io_gpio_inst_GPIO54  ( HPS_KEY   ),  //                               .hps_io_gpio_inst_GPIO54
	  .hps_io_hps_io_gpio_inst_GPIO61  ( HPS_GSENSOR_INT ),  //                               .hps_io_gpio_inst_GPIO61
		//FPGA Partion
	  .led_pio_external_connection_export    ( fpga_led_internal 	),    //    led_pio_external_connection.export

	  .hps_0_h2f_reset_reset_n               ( hps_fpga_reset_n ),                //                hps_0_h2f_reset.reset_n
	  .hps_0_f2h_cold_reset_req_reset_n      (~hps_cold_reset ),      //       hps_0_f2h_cold_reset_req.reset_n
     .hps_0_f2h_debug_reset_req_reset_n     (~hps_debug_reset ),     //      hps_0_f2h_debug_reset_req.reset_n
     .hps_0_f2h_stm_hw_events_stm_hwevents  (stm_hw_events ),  //        hps_0_f2h_stm_hw_events.stm_hwevents
     .hps_0_f2h_warm_reset_req_reset_n      (~hps_warm_reset ),      //       hps_0_f2h_warm_reset_req.reset_n
	 
		// avalon interface
		.avalon_reset_reset_n				(avalon_reset_reset_n),
		.avalon_reset_lw_reset_n			(avalon_reset_lw_reset_n),
		.avalon_clk_clk                  	(avalon_clk_clk),                  //     avalon_clk.clk
		.avalon_clk_lw_clk					(avalon_clk_lw_clk),
		// fpga to hps
		.avalon_f2h_waitrequest          	(avalon_f2h_waitrequest),          //     avalon_f2h.waitrequest
        .avalon_f2h_readdata             	(avalon_f2h_readdata),             //               .readdata
        .avalon_f2h_readdatavalid        	(avalon_f2h_readdatavalid),        //               .readdatavalid
        .avalon_f2h_burstcount           	(avalon_f2h_burstcount),           //               .burstcount
        .avalon_f2h_writedata            	(avalon_f2h_writedata),            //               .writedata
        .avalon_f2h_address              	(avalon_f2h_address),              //               .address
        .avalon_f2h_write                	(avalon_f2h_write),                //               .write
        .avalon_f2h_read                 	(avalon_f2h_read),                 //               .read
		.avalon_f2h_byteenable			 	(avalon_f2h_byteenable),		   //               .byteenable
		.avalon_f2h_beginbursttransfer      (avalon_f2h_beginbursttransfer),   //               .beginbursttransfer
		.avalon_f2h_begintransfer           (avalon_f2h_begintransfer),        //               .begintransfer
		// fpga2sdram0
        .avalon_f2s0_waitrequest          	(avalon_f2s0_waitrequest),          //     avalon_f2s0.waitrequest
        .avalon_f2s0_readdata             	(avalon_f2s0_readdata),             //               .readdata
        .avalon_f2s0_readdatavalid        	(avalon_f2s0_readdatavalid),        //               .readdatavalid
        .avalon_f2s0_burstcount           	(avalon_f2s0_burstcount),           //               .burstcount
        .avalon_f2s0_writedata            	(avalon_f2s0_writedata),            //               .writedata
        .avalon_f2s0_address              	(avalon_f2s0_address),              //               .address
        .avalon_f2s0_write                	(avalon_f2s0_write),                //               .write
        .avalon_f2s0_read                 	(avalon_f2s0_read),                 //               .read
        .avalon_f2s0_byteenable           	(avalon_f2s0_byteenable),           //               .byteenable
		// fpga2sdram1
        .avalon_f2s1_waitrequest          	(avalon_f2s1_waitrequest),          //     avalon_f2s1.waitrequest
        .avalon_f2s1_readdata             	(avalon_f2s1_readdata),             //               .readdata
        .avalon_f2s1_readdatavalid        	(avalon_f2s1_readdatavalid),        //               .readdatavalid
        .avalon_f2s1_burstcount           	(avalon_f2s1_burstcount),           //               .burstcount
        .avalon_f2s1_writedata            	(avalon_f2s1_writedata),            //               .writedata
        .avalon_f2s1_address              	(avalon_f2s1_address),              //               .address
        .avalon_f2s1_write                	(avalon_f2s1_write),                //               .write
        .avalon_f2s1_read                 	(avalon_f2s1_read),                 //               .read
        .avalon_f2s1_byteenable           	(avalon_f2s1_byteenable),           //               .byteenable
		// fpga2sdram2
        .avalon_f2s2_waitrequest          	(avalon_f2s2_waitrequest),          //     avalon_f2s2.waitrequest
        .avalon_f2s2_readdata             	(avalon_f2s2_readdata),             //               .readdata
        .avalon_f2s2_readdatavalid        	(avalon_f2s2_readdatavalid),        //               .readdatavalid
        .avalon_f2s2_burstcount           	(avalon_f2s2_burstcount),           //               .burstcount
        .avalon_f2s2_writedata            	(avalon_f2s2_writedata),            //               .writedata
        .avalon_f2s2_address              	(avalon_f2s2_address),              //               .address
        .avalon_f2s2_write                	(avalon_f2s2_write),                //               .write
        .avalon_f2s2_read                 	(avalon_f2s2_read),                 //               .read
        .avalon_f2s2_byteenable           	(avalon_f2s2_byteenable),           //               .byteenable
		// hps to fpga
		.avalon_h2f_address                   (avalon_h2f_address),                   //                  avalon_h2f.address
		.avalon_h2f_write                     (avalon_h2f_write),                     //                            .write
		.avalon_h2f_read                      (avalon_h2f_read),                      //                            .read
		.avalon_h2f_readdata                  (avalon_h2f_readdata),                  //                            .readdata
		.avalon_h2f_writedata                 (avalon_h2f_writedata),                 //                            .writedata
		.avalon_h2f_begintransfer             (avalon_h2f_begintransfer),             //                            .begintransfer
		.avalon_h2f_beginbursttransfer        (avalon_h2f_beginbursttransfer),        //                            .beginbursttransfer
		.avalon_h2f_burstcount                (avalon_h2f_burstcount),                //                            .burstcount
		.avalon_h2f_byteenable                (avalon_h2f_byteenable),                //                            .byteenable
		.avalon_h2f_readdatavalid             (avalon_h2f_readdatavalid),             //                            .readdatavalid
		.avalon_h2f_waitrequest               (avalon_h2f_waitrequest),               //                            .waitrequest
		// hps to fpga light-weight
		.avalon_h2f_lw_address                (avalon_h2f_lw_address),                //               avalon_h2f_lw.address
		.avalon_h2f_lw_write                  (avalon_h2f_lw_write),                  //                            .write
		.avalon_h2f_lw_read                   (avalon_h2f_lw_read),                   //                            .read
		.avalon_h2f_lw_readdata               (avalon_h2f_lw_readdata),               //                            .readdata
		.avalon_h2f_lw_writedata              (avalon_h2f_lw_writedata),              //                            .writedata
		.avalon_h2f_lw_begintransfer          (avalon_h2f_lw_begintransfer),          //                            .begintransfer
		.avalon_h2f_lw_beginbursttransfer     (avalon_h2f_lw_beginbursttransfer),     //                            .beginbursttransfer
		.avalon_h2f_lw_burstcount             (avalon_h2f_lw_burstcount),             //                            .burstcount
		.avalon_h2f_lw_byteenable             (avalon_h2f_lw_byteenable),             //                            .byteenable
		.avalon_h2f_lw_readdatavalid          (avalon_h2f_lw_readdatavalid),          //                            .readdatavalid
		.avalon_h2f_lw_waitrequest            (avalon_h2f_lw_waitrequest),            //                            .waitrequest
		
		/// PIO交换信息
		.video_block_number_export				({32'D0, MT9D111_FRAME_CURR}),	// 摄像头数据正在写入的区间
		.cnn_inst_info_export					({cnn_inst_time, cnn_inst_ready}),		// 观察CNN指令是否已经完成
		// 这里是行人检测加框后，图像存储的内存块区间计数
		.pd_bbox_frame_export                 (PD_BBOX_FRAME)                  //               pd_bbox_frame.export
		
 );
 
 
`else // 如果没有使用HPS
	assign	fpga_led_internal = 7'H7F;
	assign	avalon_f2s0_waitrequest = 1'B0;
	reg		[1:0]	avalon_f2s0_readdatavalid_shifter;
	always @(posedge avalon_clk_clk)
		if(!avalon_reset_reset_n)
			avalon_f2s0_readdatavalid_shifter <= 2'B00;
		else 
			avalon_f2s0_readdatavalid_shifter <= {avalon_f2s0_readdatavalid_shifter[0], avalon_f2s0_read & !avalon_f2s0_waitrequest};
	assign	avalon_f2s0_readdatavalid = avalon_f2s0_readdatavalid_shifter[1];
	assign	avalon_f2h_waitrequest = 1'B0;
`endif
/////////////////////////////////////////////////////////////////////////////////////
// Debounce logic to clean out glitches within 1ms
debounce debounce_inst (
  .clk                                  (fpga_clk_50),
  .reset_n                              (hps_fpga_reset_n),  
  .data_in                              (KEY),
  .data_out                             (fpga_debounced_buttons)
);
  defparam debounce_inst.WIDTH = 2;
  defparam debounce_inst.POLARITY = "LOW";
  defparam debounce_inst.TIMEOUT = 50000;               // at 50Mhz this is a debounce time of 1ms
  defparam debounce_inst.TIMEOUT_WIDTH = 16;            // ceil(log2(TIMEOUT))
  
// Source/Probe megawizard instance
hps_reset hps_reset_inst (
  .source_clk (fpga_clk_50),
  .source     (hps_reset_req)
);

altera_edge_detector pulse_cold_reset (
  .clk       (fpga_clk_50),
  .rst_n     (hps_fpga_reset_n),
  .signal_in (hps_reset_req[0]),
  .pulse_out (hps_cold_reset)
);
  defparam pulse_cold_reset.PULSE_EXT = 6;
  defparam pulse_cold_reset.EDGE_TYPE = 1;
  defparam pulse_cold_reset.IGNORE_RST_WHILE_BUSY = 1;

altera_edge_detector pulse_warm_reset (
  .clk       (fpga_clk_50),
  .rst_n     (hps_fpga_reset_n),
  .signal_in (hps_reset_req[1]),
  .pulse_out (hps_warm_reset)
);
  defparam pulse_warm_reset.PULSE_EXT = 2;
  defparam pulse_warm_reset.EDGE_TYPE = 1;
  defparam pulse_warm_reset.IGNORE_RST_WHILE_BUSY = 1;
  
altera_edge_detector pulse_debug_reset (
  .clk       (fpga_clk_50),
  .rst_n     (hps_fpga_reset_n),
  .signal_in (hps_reset_req[2]),
  .pulse_out (hps_debug_reset)
);
  defparam pulse_debug_reset.PULSE_EXT = 32;
  defparam pulse_debug_reset.EDGE_TYPE = 1;
  defparam pulse_debug_reset.IGNORE_RST_WHILE_BUSY = 1;

reg [25:0] counter; 
reg  led_level;
always @	(posedge fpga_clk_50 or negedge hps_fpga_reset_n)
begin
if(~hps_fpga_reset_n)
begin
		counter<=0;
		led_level<=0;
end

else if(counter==24999999)
	begin
		counter<=0;
		led_level<=~led_level;
	end
else
		counter<=counter+1'b1;
end

//assign LED[0]=led_level;
endmodule
