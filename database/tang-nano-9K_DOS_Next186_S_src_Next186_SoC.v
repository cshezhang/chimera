
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module Next186_SoC(
// CLOCK
	input clk27M, // clk50m,

// HDMI
	output       tmds_clk_n,
	output       tmds_clk_p,
	output [2:0] tmds_d_n,
	output [2:0] tmds_d_p,

// PSRAM(Internal connection)
	output wire [1:0] 	O_psram_ck,
	output wire [1:0] 	O_psram_ck_n,
	inout  wire [1:0] 	IO_psram_rwds,
	inout  wire [15:0]	IO_psram_dq,
	output wire [1:0] 	O_psram_reset_n,
	output wire [1:0] 	O_psram_cs_n,

// SPI
	//output flash_ncs,		// active low
	//output rtc_cs,			// active high
	//input mmc_ncd,			// low when card present
	//input mmc_wp,  		// high on write protect
	output mmc_ncs,		// SD-CARD active low
	output spi_clk,
	input spi_miso,
	output spi_mosi,
	output [1:0] spi_pup,
	
// PS2
	//inout ps2_mouse_dat,
	//inout ps2_mouse_clk,
	inout ps2_kb_dat,
	inout ps2_kb_clk,	

// RS232
	input usart_rx,
	output usart_tx,
	//input usart_rts,
	//output usart_clk,
	
// AUDIO	
	//output sigma_l,
	//output sigma_r,
	
// IR
	//input ir_data,
	
// BUTTONS - normal 1, 0 when pushed
	//input usart_cts,		// left
	//input freeze_btn,		// middle
	//input reset_btn,		// right
	
	input  [1:0] 	BTN,	// BTN[1]=reset
	//output [5:0]	gpio,
    output [5:0]	LED
	
);

	assign LED = ~{GPIO[3:0],spi_mosi,spi_miso};

	wire CLK44100x256;
	wire r0, g0, b0;
	wire [2:0]led; // {mem_access, sd_access, halt};
 	wire ps2_kb_clk_nOE;
	wire ps2_kb_data_nOE;
	wire ps2_mouse_clk_nOE;
	wire ps2_mouse_data_nOE;
	wire [7:0] GPIO;

	assign ram_cs = 1'b0; 		//// 
	assign spi_pup = 2'b11;		////
	assign ps2iec_sel = 1'b0;	// ps2 active
	assign flash_ncs = 1'b1;	// flash inactive
	assign rtc_cs = 1'b0;		// rtc inactive
/*
	wire clk50m,clk1m;
	clk50m	clk50m_inst (
		.inclk0 ( clk12m ),	.c0 ( clk50m ),	.locked (  ));
	wire SDR_CLK,wire clk_25;
	dd_buf sdrclk_buf(
		.datain_h(1'b1),.datain_l(1'b0),.outclock(SDR_CLK),.dataout(ram_clk));
*/
	wire clk_ps,pll_lock1,pll_lock2;
	wire pll_lock = pll_lock1 && pll_lock2;
    Gowin_rPLL clkgen(
        .clkin(clk27M),
        .clkout(clk_ps),	// 54M   -> 72M
        .clkoutd(clk50m),	// 13.5M -> 18M
        .lock(pll_lock1)
    );

  wire clk_p, clk_p5;	// p5:125.875  p:25.175
  Gowin_rPLL2 u_pll (.clkin(clk27M), .clkout(clk_p5), .lock(pll_lock2) );
  Gowin_CLKDIV u_div_5 ( .clkout(clk_p), .hclkin(clk_p5), .resetn(pll_lock2) );

wire breset = ~BTN[1];
wire resetn = 1'b1;
wire clk_pixel = clk_p;

	wire [5:0] rout,gout,bout;
	wire vdma_tvalid;
	wire vdma_tready;
	wire [24-1:0] vdma_tdata;	// SVO_BITS_PER_PIXEL = 24
	wire [0:0] vdma_tuser;
	wire [3:0] enc_tuser;
	wire hsync_ns,vsync_ns;
	wire hblnk;

svo_hdmi_out u_hdmi (
	//.clk(clk_p),
	.resetn(~breset),//(sys_resetn),
	// video clocks
	.clk_pixel(clk_p),
	.clk_5x_pixel(clk_p5),
	.locked(pll_lock),
	// input VGA
	.rout(rout),
	.gout(gout),
	.bout(bout),
	.hsync_n(hsync_n),
	.vsync_n(vsync_n),
	.hblnk_n(hblnk_n),
	// output signals
	.tmds_clk_n(tmds_clk_n),
	.tmds_clk_p(tmds_clk_p),
	.tmds_d_n(tmds_d_n),
	.tmds_d_p(tmds_d_p),
	.tmds_ts()
);

	// Adjust Hsync & Vsync Position
	assign hsync_n = hsync_ns;
	//assign vsync_n = vsync_ns;
	reg vsync_n; 

	wire hblnk_ns;
	reg hblnk_nsd, hblnk_n,hsync_nsd;
	reg [5:0] hblnk_dct;
	reg [15:0] hblnk_sft;
	always @ (posedge clk_pixel) begin
		//hblnk_sft <= { hblnk_sft[14:0], hblnk_ns};
		//hblnk_n <= hblnk_sft[15];
		hblnk_nsd <= hblnk_ns;
		if(hblnk_ns!=hblnk_nsd) hblnk_dct <= 18;
		else begin
			if(hblnk_dct==1) begin
				hblnk_n <= hblnk_ns;
			end
			hblnk_dct <= hblnk_dct - 1;
		end
		//
		hsync_nsd <= hsync_ns;
		if(hsync_ns && ~hsync_nsd) vsync_n <= vsync_ns;
	end

	reg [7:0] pixel_div;
	always @ (posedge clk_pixel) pixel_div <= pixel_div + 1;
/*
	reg hsync_nr;
	assign hsync_n = hsync_nr;
	reg hsync_sd;
	reg [15:0] hsync_sft;
	always @ (posedge clk_pixel) begin
		hsync_sd <= ~hsync_sd;
		if(hsync_sd) begin 
			hsync_sft <= { hsync_sft[14:0], hsync_ns};
			hsync_nr <= hsync_sft[15];
		end;
	end
	reg vsync_nr;
	assign vsync_n = vsync_nr;
	reg [21:0] vsync_sft;
	always @ (negedge hsync_ns) begin
		vsync_sft <= { vsync_sft[20:0], vsync_ns};
		vsync_nr <= vsync_sft[21];
	end
*/
	system sys_inst
	(
		//.clk_sdr(clk_ps),
 		//.sdr_CLK_out(SDR_CLK),
		.CLK_50MHZ(clk50m),
		.clk_pixel(clk_pixel),
		.VGA_R(rout),
		.VGA_G(gout),
		.VGA_B(bout),
		.frame_on(),
		.VGA_HSYNC(hsync_ns),
		.VGA_VSYNC(vsync_ns),
		.VGA_hblnk(hblnk_ns),
		.LED(led),
		.BTN_RESET(breset),
		.BTN_NMI(1'b0), // (!freeze_btn),
		.BTN_USER(BTN[0]),
		.RS232_DCE_RXD(usart_rx),
		.RS232_DCE_TXD(usart_tx),
		.RS232_EXT_RXD(1'b1),
		.RS232_EXT_TXD(),
		 // PSRAM(Internal connection)
		.psram_clk(clk_ps),
		.pll_lock(pll_lock),
		.O_psram_ck(O_psram_ck),
		.O_psram_ck_n(O_psram_ck_n),
		.IO_psram_rwds(IO_psram_rwds),
		.IO_psram_dq(IO_psram_dq),
		.O_psram_reset_n(O_psram_reset_n),
		.O_psram_cs_n(O_psram_cs_n),

		.SD_n_CS(mmc_ncs),
		.SD_DI(spi_mosi),
		.SD_CK(spi_clk),
		.SD_DO(spi_miso),
		.AUD_L(sigma_l),
		.AUD_R(sigma_r),

	 	.PS2_CLK1(ps2_kb_clk),
 	   //.PS2_CLK1_nOE(ps2_kb_clk_nOE),
		.PS2_DATA1(ps2_kb_dat),
		//.PS2_DATA1_nOE(ps2_kb_data_nOE),

		.PS2_CLK2(ps2_mouse_clk),
		//.PS2_CLK2_nOE(ps2_mouse_clk_nOE),
		.PS2_DATA2(ps2_mouse_dat),
		//.PS2_DATA2_nOE(ps2_mouse_data_nOE),

		.RS232_HOST_RXD(1'b1),
		.RS232_HOST_TXD(),
		.RS232_HOST_RST(),
		.GPIO(GPIO),
		.I2C_SCL(),
		.I2C_SDA()
	);
	
endmodule

